#include "librop.h"

kernel_map_t *kernel_map_file(const char *path)
{
    int fd = open(path, O_RDONLY);
    if (fd < 0)
        return 0;

    struct stat sb;
    fstat(fd, &sb);

    void *map = mmap(NULL, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);

    kernel_map_t *km = (kernel_map_t *) malloc(sizeof(kernel_map_t));
    km->map  = map;
    km->sz = sb.st_size;
    return km;
}

uint64_t kernel_base(kernel_map_t *mapping)
{
    struct mach_header_64 *mh = mapping->map;
    struct segment_command_64 *text = find_segment_64(mh, SEG_TEXT);
    return (uint64_t)text->vmaddr;
}

uint64_t find_gadget(kernel_map_t *mapping, const char *bytes, const uint8_t size)
{
    uint64_t offset = (uint64_t) memmem(mapping->map, mapping->sz, bytes, size);
    if (!offset)
    {
        printf("Gadget not found, quiting.\n");
        exit(1);
    }
    return kernel_base(mapping) + (offset - (uint64_t) mapping->map);
}

uint64_t find_symbol_address(kernel_map_t *mapping, const char *symbol_name)
{
    void *symbol_table = NULL, *string_table = NULL;
    uint32_t nsymbols = 0;

    struct mach_header_64 *mh = mapping->map;
    struct symtab_command *symtab_cmd = (struct symtab_command *)find_load_command(mapping, LC_SYMTAB);

    if (!symtab_cmd)
        return 0;

    symbol_table = ((void *)mh + symtab_cmd->symoff);
    string_table = ((void *)mh + symtab_cmd->stroff);
    nsymbols = symtab_cmd->nsyms;

    struct nlist_64 *entry = (struct nlist_64 *)symbol_table;

    for (uint32_t i = 0; i < nsymbols; ++i)
    {
        if (strcmp(string_table + (entry->n_un.n_strx), symbol_name) == 0)
        {
            return entry->n_value;
        }
        entry = ((void *)entry + sizeof(struct nlist_64));
    }

    printf("Symbol '%s' not found, quiting.\n", symbol_name);
    exit(1);
}

struct segment_command_64 *find_segment_64(struct mach_header_64 *mh, const char *segname)
{
    struct load_command *lc;
    struct segment_command_64 *s;
    lc = (struct load_command *)((uint64_t)mh + sizeof(struct mach_header_64));

    for (int i = 0; i < mh->ncmds; ++i)
    {
        if (lc->cmd == LC_SEGMENT_64)
        {
            s = (struct segment_command_64 *)lc;
            if (!strcmp(s->segname, segname))
            {
                return s;
            }
        }
        lc = (struct load_command *)((uint64_t)lc + (uint64_t)lc->cmdsize);
    }
    return 0;
}

struct load_command *find_load_command(kernel_map_t *mapping, uint32_t cmd)
{
    struct mach_header_64 *mh = mapping->map;
    struct load_command *lc, *flc;

    lc = (struct load_command *)((uint64_t)mh + sizeof(struct mach_header_64));

    for (int i = 0; i < mh->ncmds; ++i)
    {
        if (lc->cmd == cmd)
        {
            return lc;
        }
        lc = (struct load_command *)((uint64_t)lc + (uint64_t)lc->cmdsize);
    }
    return 0;
}